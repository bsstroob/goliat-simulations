{"config":{"lang":["en"],"separator":"[\\s\\-,:!=\\[\\]()\"`/]+|\\.(?!\\d)|&[lg]t;|(?!\\b)(?=[A-Z][a-z])","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to GOLIAT","text":"<p>GOLIAT is an automated Python framework for near-field and far-field dosimetric assessments using the Sim4Life simulation platform. It streamlines EMF exposure simulations for research and compliance.</p> <ul> <li> <p> Quick Start</p> <p>Get running in minutes with installation and your first simulation.</p> <p> Get Started</p> </li> <li> <p> User Guide</p> <p>Understand workflows for near-field and far-field studies.</p> <p> Read Guide</p> </li> <li> <p> Tutorials</p> <p>Hands-on examples from basic runs to advanced batching.</p> <p> View Tutorials</p> </li> <li> <p> Configuration</p> <p>Customize simulations with JSON configs.</p> <p> Configure</p> </li> <li> <p> API Reference</p> <p>Detailed docs for classes and functions.</p> <p> API Docs</p> </li> <li> <p> Technical Guide</p> <p>Overview of the system design.</p> <p> Technical Guide</p> </li> </ul>"},{"location":"#overview","title":"Overview","text":"<p>GOLIAT automates dosimetric assessments for the GOLIAT project, calculating SAR in digital human phantoms from device or environmental EMF exposure. Key features:</p> <ul> <li>Modular scene building (phantoms, antennas, plane waves).</li> <li>Local or cloud execution (iSolve/oSPARC).</li> <li>Results extraction and analysis (SAR metrics, plots).</li> <li>GUI for progress tracking.</li> <li>Automatic disk space management for serial workflows.</li> </ul> <p>Start with the Quick Start to run your first simulation.</p>"},{"location":"#why-goliat","title":"Why GOLIAT?","text":"<ul> <li>Efficiency: Handles setup, runs, and analysis in one tool.</li> <li>Reproducible: Config-driven for consistent results.</li> <li>Scalable: Local parallel or cloud batching for large studies.</li> <li>Accessible: Plain-language docs for newcomers.</li> </ul> <p>For issues, see Troubleshooting. Contribute via Developer Guide.</p>"},{"location":"COLORING_RULES/","title":"Coloring Rules for Terminal Output","text":"<p>This document outlines the rules for colorizing terminal output using the <code>colorama</code> library. The goal is to improve readability and draw the user's attention to the most critical information. All colors are defined in the <code>COLOR_MAP</code> dictionary in <code>src/colors.py</code> to ensure consistency and ease of maintenance.</p>"},{"location":"COLORING_RULES/#how-to-use","title":"How to use","text":"<p>To apply a color, use the <code>_log</code> method from the <code>LoggingMixin</code> and specify the <code>log_type</code>.</p> <pre><code># Example usage:\nself._log(\"This is a warning message.\", log_type='warning')\nself._log(\"File saved successfully.\", level='progress', log_type='success')\n</code></pre> <p>Important: When adding a <code>log_type</code>, do not change the existing <code>level</code> parameter (e.g., <code>level='progress'</code>). The <code>level</code> controls which log file the message goes to, while <code>log_type</code> only controls the terminal color.</p>"},{"location":"COLORING_RULES/#color-to-type-mapping","title":"Color-to-type mapping","text":"<p>This table defines the intended use for each <code>log_type</code> and its corresponding color.</p> <code>log_type</code> Color Description &amp; Use Cases Example <code>default</code> White Standard, neutral output. Used for messages that don't fit any other category. <code>Running full simulation setup...</code> <code>header</code> Bright Magenta For major section headers that announce the start of a significant phase of the study. <code>--- Starting Far-Field Study: My Study ---</code> <code>progress</code> Green High-level progress updates that indicate a specific, positive step forward in the process. <code>--- Processing Frequency 1/5: 700MHz ---</code> <code>success</code> Bright Green Indicates the successful completion of a major operation or the entire study. <code>--- Study Finished ---</code> or <code>All required packages are already installed.</code> <code>info</code> Cyan Important, non-critical information that provides context, such as file paths or key configuration settings. <code>Project path set to: D:\\...</code> or <code>Solver kernel set to: Acceleware</code> <code>highlight</code> Bright Yellow Used to draw attention to a specific value or result within a block of text, such as a key performance metric. <code>Final Balance: 99.87%</code> <code>warning</code> Yellow For non-critical issues or potential problems that the user should be aware of, but that don't stop the process. <code>WARNING: Could not extract power balance.</code> or <code>GetPower() not available, falling back to manual extraction.</code> <code>error</code> Red For recoverable errors or failures within a specific part of the process. The overall study may continue. <code>ERROR: An error occurred during placement 'by_cheek': ...</code> <code>fatal</code> Magenta For critical, non-recoverable errors that will terminate the study. <code>FATAL ERROR: Could not find simulation bounding box.</code> <code>verbose</code> Blue Detailed, low-level debugging information intended for the <code>verbose</code> log stream. Not typically for progress updates. <code>- Activating line profiler for subtask: setup_simulation</code> <p>By following these rules, we can create a more intuitive and effective user experience.</p>"},{"location":"advanced_features/","title":"Advanced Features: A Deeper Dive","text":"<p>This section details the architecture and workflow of the key operational features of the codebase, focusing on the graphical user interface (GUI), logging, session management, and the profiling/timing system.</p>"},{"location":"advanced_features/#1-high-level-workflow","title":"1. High-level workflow","text":"<p>The application is designed to run scientific studies (e.g., Near-Field, Far-Field) which can be time-consuming. To provide user feedback and manage complexity, the system employs a multi-process architecture.</p> <ol> <li>Main Process: A lightweight PySide6 GUI (<code>ProgressGUI</code>) is launched. This GUI is responsible for displaying progress, logs, and timing information.</li> <li>Study Process: The actual study (<code>NearFieldStudy</code> or <code>FarFieldStudy</code>) is executed in a separate process using Python's <code>multiprocessing</code> module. This prevents the GUI from freezing during intensive calculations.</li> <li>Communication: The study process communicates with the GUI process through a <code>multiprocessing.Queue</code>. It sends messages containing status updates, progress information, and timing data.</li> </ol> <p>The entry point for the study process is the <code>study_process_wrapper</code> function, which sets up a special <code>QueueGUI</code> object. This object mimics the real GUI's interface but directs all its output to the shared queue.</p> <pre><code># from src/gui_manager.py\ndef study_process_wrapper(queue, study_type, config_filename, verbose, session_timestamp, execution_control):\n    \"\"\"\n    This function runs in a separate process and executes the study.\n    It communicates with the main GUI process via a queue.\n    \"\"\"\n    # ... setup ...\n    class QueueGUI:\n        def __init__(self, queue):\n            self.queue = queue\n            self.profiler = None\n\n        def log(self, message, level='verbose'):\n            if level == 'progress':\n                self.queue.put({'type': 'status', 'message': message})\n\n        def update_overall_progress(self, current_step, total_steps):\n            self.queue.put({'type': 'overall_progress', 'current': current_step, 'total': total_steps})\n        # ... other methods ...\n\n    if study_type == 'near_field':\n        study = NearFieldStudy(config_filename=config_filename, verbose=verbose, gui=QueueGUI(queue))\n    # ...\n    study.run()\n    queue.put({'type': 'finished'})\n</code></pre> <pre><code>graph TD\n    A[Main Process: ProgressGUI] -- Spawns --&gt; B[Study Process: study_process_wrapper];\n    B -- Instantiates --&gt; Study[NearFieldStudy/FarFieldStudy];\n    Study -- Uses --&gt; QueueGUI[QueueGUI object];\n    QueueGUI -- Puts messages --&gt; C{multiprocessing.Queue};\n    C -- Polled by QTimer --&gt; A;\n    A -- Updates UI --&gt; D[User];</code></pre>"},{"location":"advanced_features/#2-gui-gui_managerpy","title":"2. GUI (<code>gui_manager.py</code>)","text":"<p>The GUI provides a real-time view of the study's progress. It runs in the main process and is designed to be responsive, even while the heavy computation happens elsewhere.</p>"},{"location":"advanced_features/#message-processing","title":"Message processing","text":"<p>The <code>ProgressGUI</code> uses a <code>QTimer</code> that fires every 100ms, calling the <code>process_queue</code> method. This method drains the queue of any pending messages from the study process and updates the UI accordingly.</p> <pre><code># from src/gui_manager.py\nclass ProgressGUI(QWidget):\n    # ...\n    def process_queue(self):\n        while not self.queue.empty():\n            try:\n                msg = self.queue.get_nowait()\n                msg_type = msg.get('type')\n\n                if msg_type == 'status':\n                    self.update_status(msg['message'])\n                elif msg_type == 'overall_progress':\n                    self.update_overall_progress(msg['current'], msg['total'])\n                elif msg_type == 'stage_progress':\n                    self.update_stage_progress(msg['name'], msg['current'], msg['total'])\n                elif msg_type == 'start_animation':\n                    self.start_stage_animation(msg['estimate'], msg['end_value'])\n                # ... other message types ...\n            except Empty:\n                break\n</code></pre>"},{"location":"advanced_features/#the-animation-system-a-closer-look","title":"The animation system: a closer look","text":"<p>A key feature for user experience is the smooth animation of the stage progress bar. This is used for tasks where the simulation software doesn't provide real-time progress feedback, but we have a historical estimate of how long it should take.</p> <p>How it works:</p> <ol> <li> <p>Initiation: The study process, before starting a long-running subtask (like <code>run_simulation_total</code>), gets an estimated duration from the <code>Profiler</code>. It then sends a <code>start_animation</code> message to the GUI, containing this estimated duration.     <pre><code># from src/studies/far_field_study.py (conceptual)\ndef run_simulations(self):\n    # ...\n    if self.gui:\n        # Tell the GUI to start an animation for the next step\n        self.gui.start_stage_animation(\"run_simulation_total\", i + 1)\n    self.simulation_runner.run(sim)\n</code></pre>     The <code>QueueGUI</code> object in the study process gets the estimate from its profiler instance and puts the message on the queue.     <pre><code># from src/gui_manager.py\nclass QueueGUI:\n    # ...\n    def start_stage_animation(self, task_name, end_value):\n        estimate = self.profiler.get_subtask_estimate(task_name)\n        self.queue.put({'type': 'start_animation', 'estimate': estimate, 'end_value': end_value})\n</code></pre></p> </li> <li> <p>Animation Setup: When the <code>ProgressGUI</code> receives the <code>start_animation</code> message, it sets up the animation parameters. It records the <code>start_time</code>, the <code>duration</code> (from the profiler's estimate), the progress bar's <code>start_value</code>, and the <code>end_value</code> it needs to reach.     <pre><code># from src/gui_manager.py\ndef start_stage_animation(self, estimated_duration, end_step):\n    self.animation_start_time = time.time()\n    self.animation_duration = estimated_duration\n    self.animation_start_value = self.stage_progress_bar.value()\n    # ... calculate animation_end_value based on end_step ...\n\n    self.animation_active = True\n    if not self.animation_timer.isActive():\n        self.animation_timer.start(50) # Start the animation timer (50ms interval)\n</code></pre></p> </li> <li> <p>Frame-by-Frame Update: A dedicated <code>QTimer</code> (<code>animation_timer</code>) calls the <code>update_animation</code> method every 50ms. This method calculates how much time has passed since the animation started, determines the corresponding progress percentage, and updates the progress bar's value. This creates the smooth visual effect.     <pre><code># from src/gui_manager.py\ndef update_animation(self):\n    if not self.animation_active:\n        return\n\n    elapsed = time.time() - self.animation_start_time\n\n    if self.animation_duration &gt; 0:\n        progress_ratio = min(elapsed / self.animation_duration, 1.0)\n    else:\n        progress_ratio = 1.0\n\n    value_range = self.animation_end_value - self.animation_start_value\n    current_value = self.animation_start_value + int(value_range * progress_ratio)\n\n    self.stage_progress_bar.setValue(current_value)\n</code></pre></p> </li> <li> <p>Termination: Once the actual task is complete in the study process, it sends an <code>end_animation</code> message. This stops the animation timer and sets the progress bar to its final, accurate value, correcting for any deviation between the estimate and the actual time taken.</p> </li> </ol>"},{"location":"advanced_features/#3-logging-logging_managerpy","title":"3. Logging (<code>logging_manager.py</code>)","text":"<p>The system uses Python's standard <code>logging</code> module, configured to provide two distinct streams of information.</p>"},{"location":"advanced_features/#loggers","title":"Loggers:","text":"<ol> <li><code>progress</code> logger: For high-level, user-facing messages. These are shown in the GUI and saved to <code>*.progress.log</code>.</li> <li><code>verbose</code> logger: For detailed, internal messages. These are saved to the main <code>*.log</code> file.</li> </ol>"},{"location":"advanced_features/#implementation-details","title":"Implementation details:","text":"<ul> <li>Log Rotation: The <code>setup_loggers</code> function checks the number of log files in the <code>logs</code> directory. If it exceeds a limit (15 pairs), it deletes the oldest pair (<code>.log</code> and <code>.progress.log</code>) to prevent the directory from growing indefinitely.</li> <li>Handler Configuration: The function creates file handlers and stream (console) handlers for each logger, ensuring messages go to the right places. <code>propagate = False</code> is used to prevent messages from being handled by parent loggers, avoiding duplicate output.</li> </ul> <pre><code># from src/logging_manager.py\ndef setup_loggers(session_timestamp=None):\n    # ... log rotation logic ...\n\n    progress_logger = logging.getLogger('progress')\n    progress_logger.setLevel(logging.INFO)\n    # Remove existing handlers to prevent duplicates\n    for handler in progress_logger.handlers[:]:\n        progress_logger.removeHandler(handler)\n\n    # File handler for progress file\n    progress_file_handler = logging.FileHandler(progress_log_filename, mode='a')\n    progress_logger.addHandler(progress_file_handler)\n\n    # Stream handler for progress (console output)\n    progress_stream_handler = logging.StreamHandler()\n    progress_logger.addHandler(progress_stream_handler)\n    progress_logger.propagate = False\n\n    # ... similar setup for verbose_logger ...\n    return progress_logger, verbose_logger, session_timestamp\n</code></pre>"},{"location":"advanced_features/#4-profiling-and-timing-utilspy-profiling_configjson","title":"4. Profiling and timing (<code>utils.py</code>, <code>profiling_config.json</code>)","text":"<p>The <code>Profiler</code> class is the engine for the timing and progress estimation system.</p>"},{"location":"advanced_features/#key-concepts","title":"Key concepts:","text":"<ul> <li>Phases and Weights: A study is divided into phases (<code>setup</code>, <code>run</code>, <code>extract</code>). <code>profiling_config.json</code> assigns a \"weight\" to each, representing its contribution to the total time.     <pre><code>// from configs/profiling_config.json\n{\n    \"phase_weights\": {\n        \"setup\": 0.299,\n        \"run\": 0.596,\n        \"extract\": 0.105\n    },\n    \"subtask_estimates\": {\n        \"setup_simulation\": 48.16,\n        \"run_simulation_total\": 107.54,\n        \"extract_sar_statistics\": 4.09\n    }\n}\n</code></pre></li> <li>Dynamic Weights: The profiler normalizes these weights based on which phases are active (controlled by <code>execution_control</code> in the config). If a user chooses to only run the <code>extract</code> phase, its weight becomes 1.0, and the progress for that phase represents 100% of the total work.</li> <li>Weighted Progress: The <code>get_weighted_progress</code> method provides a more accurate overall progress.     <pre><code># from src/utils.py\ndef get_weighted_progress(self, phase_name, phase_progress):\n    \"\"\"Calculates the overall progress based on phase weights.\"\"\"\n    total_progress = 0\n    for phase, weight in self.phase_weights.items():\n        if phase == phase_name:\n            total_progress += weight * phase_progress # Add partial progress of current phase\n        elif phase in self.completed_phases:\n            total_progress += weight # Add full weight of completed phases\n    return total_progress * 100\n</code></pre></li> <li>Time Estimation (ETA): The <code>get_time_remaining</code> method is adaptive. Initially, it relies on the <code>subtask_estimates</code>. Once one or more stages have completed, it switches to a more accurate method based on the actual average time taken per stage.</li> <li>Self-Improving Estimates: After a run, <code>save_estimates</code> calculates the average time for each timed subtask and writes these new averages back to <code>profiling_config.json</code>. This makes future estimates more accurate.</li> </ul>"},{"location":"advanced_features/#5-configuration-configpy","title":"5. Configuration (<code>config.py</code>)","text":"<p>The <code>Config</code> class uses a powerful inheritance mechanism to avoid duplicating settings.</p> <ul> <li> <p>Inheritance: A config can \"extend\" a base config. The <code>_load_config_with_inheritance</code> method recursively loads the base config and merges it with the child config. The child's values override the parent's.</p> <p>```python</p> </li> </ul>"},{"location":"advanced_features/#from-srcconfigpy","title":"from src/config.py","text":"<p>def _load_config_with_inheritance(self, path):     config = self._load_json(path)</p> <pre><code>if \"extends\" in config:\n    base_config_path = self._resolve_config_path(config[\"extends\"])\n    base_config = self._load_config_with_inheritance(base_config_path)\n\n    # Merge the base configuration into the current one\n    config = deep_merge(base_config, config)\n\nreturn config\n</code></pre> <p><code>``    For example,</code>near_field_config.json<code>might only specify the settings that differ from the main</code>base_config.json`.</p>"},{"location":"advanced_features/#6-project-management","title":"6. Project management","text":"<ul> <li><code>project_manager.py</code>: This class is critical for reliability. The underlying <code>.smash</code> project files can become corrupted or locked. The <code>_is_valid_smash_file</code> method is a key defensive measure. It first attempts to rename the file to itself (a trick to check for file locks on Windows) and then uses <code>h5py</code> to ensure the file is a valid HDF5 container before attempting to open it in the simulation software. This prevents the application from crashing on a corrupted file.</li> </ul>"},{"location":"api_reference/","title":"API Reference","text":""},{"location":"api_reference/#module-run_analysis","title":"Module run_analysis","text":""},{"location":"api_reference/#main","title":"main","text":"<pre><code>def main()\n</code></pre> <p>Main entry point for the analysis script.</p> <p></p>"},{"location":"api_reference/#module-run_free_space_study","title":"Module run_free_space_study","text":""},{"location":"api_reference/#consolelogger","title":"ConsoleLogger","text":"<pre><code>class ConsoleLogger()\n</code></pre> <p>A console-based logger for headless script execution.</p> <p></p>"},{"location":"api_reference/#create_temp_config","title":"create_temp_config","text":"<pre><code>def create_temp_config(base_config, frequency_mhz)\n</code></pre> <p>Creates a temporary configuration for a single free-space run.</p> <p></p>"},{"location":"api_reference/#main_1","title":"main","text":"<pre><code>def main()\n</code></pre> <p>Runs a free-space simulation for each available frequency to validate the antenna models and the core simulation pipeline.</p> <p></p>"},{"location":"api_reference/#module-run_parallel_studies","title":"Module run_parallel_studies","text":""},{"location":"api_reference/#setup_console_logging","title":"setup_console_logging","text":"<pre><code>def setup_console_logging()\n</code></pre> <p>Sets up a basic console logger with color.</p> <p></p>"},{"location":"api_reference/#split_list_into_n","title":"split_list_into_n","text":"<pre><code>def split_list_into_n(items, n)\n</code></pre> <p>Split a list into n approximately equal parts.</p> <p></p>"},{"location":"api_reference/#calculate_split_factors","title":"calculate_split_factors","text":"<pre><code>def calculate_split_factors(num_phantoms, num_items, target_splits)\n</code></pre> <p>Calculate optimal splitting factors for phantoms and items (frequencies/antennas). Prioritizes splitting phantoms first, then items.</p> <p>Returns: (phantom_splits, item_splits) where phantom_splits * item_splits = target_splits</p> <p></p>"},{"location":"api_reference/#split_config","title":"split_config","text":"<pre><code>def split_config(config_path, num_splits, logger)\n</code></pre> <p>Splits the configuration file into a number of parallel configs using smart algorithm.</p> <p></p>"},{"location":"api_reference/#run_study_process","title":"run_study_process","text":"<pre><code>def run_study_process(args)\n</code></pre> <p>Runs the study for a given config file.</p> <p></p>"},{"location":"api_reference/#main_2","title":"main","text":"<pre><code>def main()\n</code></pre> <p>Main function to split configs and run studies in parallel.</p> <p></p>"},{"location":"api_reference/#module-run_study","title":"Module run_study","text":""},{"location":"api_reference/#consolelogger_1","title":"ConsoleLogger","text":"<pre><code>class ConsoleLogger()\n</code></pre> <p>A console-based logger to substitute for the GUI.</p> <p></p>"},{"location":"api_reference/#study_process_wrapper","title":"study_process_wrapper","text":"<pre><code>def study_process_wrapper(queue, stop_event, config_filename, process_id)\n</code></pre> <p>This function runs in a separate process to execute the study. It sets up its own loggers and communicates with the main GUI process via a queue and a stop event.</p> <p></p>"},{"location":"api_reference/#main_3","title":"main","text":"<pre><code>def main()\n</code></pre> <p>Main entry point for running a study. It launches the GUI in the main process and the study in a separate process.</p> <p></p>"},{"location":"api_reference/#module-antenna","title":"Module antenna","text":""},{"location":"api_reference/#antenna","title":"Antenna","text":"<pre><code>class Antenna()\n</code></pre> <p>Manages antenna-specific properties and configurations.</p> <p></p>"},{"location":"api_reference/#__init__","title":"__init__","text":"<pre><code>def __init__(config: \"Config\", frequency_mhz: int)\n</code></pre> <p>Initializes the Antenna object.</p> <p>Arguments:</p> <ul> <li><code>config</code> - The configuration object containing antenna settings.</li> <li><code>frequency_mhz</code> - The operating frequency in MHz.</li> </ul> <p></p>"},{"location":"api_reference/#get_config_for_frequency","title":"get_config_for_frequency","text":"<pre><code>def get_config_for_frequency() -&gt; dict\n</code></pre> <p>Gets the antenna configuration for the current frequency.</p> <p>Raises:</p> <ul> <li><code>ValueError</code> - If no configuration is defined for the frequency.</li> </ul> <p>Returns:</p> <p>The antenna configuration dictionary.</p> <p></p>"},{"location":"api_reference/#get_model_type","title":"get_model_type","text":"<pre><code>def get_model_type() -&gt; str\n</code></pre> <p>Gets the antenna model type (e.g., 'PIFA', 'IFA').</p> <p></p>"},{"location":"api_reference/#get_source_entity_name","title":"get_source_entity_name","text":"<pre><code>def get_source_entity_name() -&gt; str\n</code></pre> <p>Gets the name of the source entity in the CAD model.</p> <p></p>"},{"location":"api_reference/#get_centered_antenna_path","title":"get_centered_antenna_path","text":"<pre><code>def get_centered_antenna_path(centered_antennas_dir: str) -&gt; str\n</code></pre> <p>Constructs the path to the centered .sab antenna file.</p> <p>Arguments:</p> <ul> <li><code>centered_antennas_dir</code> - The directory for centered antenna files.</li> </ul> <p>Returns:</p> <p>The absolute path to the centered antenna model file.</p> <p></p>"},{"location":"api_reference/#module-colors","title":"Module colors","text":""},{"location":"api_reference/#get_color","title":"get_color","text":"<pre><code>def get_color(log_type: str) -&gt; str\n</code></pre> <p>Retrieves the colorama color code for a given log type.</p> <p>Arguments:</p> <ul> <li><code>log_type</code> - The type of log message (e.g., 'info', 'warning').</li> </ul> <p>Returns:</p> <p>The colorama color code for the log type.</p> <p></p>"},{"location":"api_reference/#module-config","title":"Module config","text":""},{"location":"api_reference/#deep_merge","title":"deep_merge","text":"<pre><code>def deep_merge(source: dict, destination: dict) -&gt; dict\n</code></pre> <p>Recursively merges two dictionaries, overwriting destination with source values.</p> <p>Arguments:</p> <ul> <li><code>source</code> - The dictionary with values to merge.</li> <li><code>destination</code> - The dictionary to be merged into.</li> </ul> <p>Returns:</p> <p>The merged dictionary.</p> <p></p>"},{"location":"api_reference/#config","title":"Config","text":"<pre><code>class Config()\n</code></pre> <p>Manages loading and access of hierarchical JSON configurations.</p> <p></p>"},{"location":"api_reference/#__init___1","title":"__init__","text":"<pre><code>def __init__(base_dir: str, config_filename: str = \"near_field_config.json\")\n</code></pre> <p>Initializes the Config object by loading all relevant configuration files.</p> <p>Arguments:</p> <ul> <li><code>base_dir</code> - The base directory of the project.</li> <li><code>config_filename</code> - The name of the main configuration file to load.</li> </ul> <p></p>"},{"location":"api_reference/#get_setting","title":"get_setting","text":"<pre><code>def get_setting(path: str, default=None)\n</code></pre> <p>Retrieves a nested setting using a dot-separated path.</p> <p>Example:</p> <p><code>get_setting(\"simulation_parameters.number_of_point_sensors\")</code></p> <p>Arguments:</p> <ul> <li><code>path</code> - The dot-separated path to the setting.</li> <li><code>default</code> - The default value to return if the setting is not found.</li> </ul> <p>Returns:</p> <p>The value of the setting, or the default value.</p> <p></p>"},{"location":"api_reference/#get_simulation_parameters","title":"get_simulation_parameters","text":"<pre><code>def get_simulation_parameters() -&gt; dict\n</code></pre> <p>Gets the 'simulation_parameters' dictionary.</p> <p></p>"},{"location":"api_reference/#get_antenna_config","title":"get_antenna_config","text":"<pre><code>def get_antenna_config() -&gt; dict\n</code></pre> <p>Gets the 'antenna_config' dictionary.</p> <p></p>"},{"location":"api_reference/#get_gridding_parameters","title":"get_gridding_parameters","text":"<pre><code>def get_gridding_parameters() -&gt; dict\n</code></pre> <p>Gets the 'gridding_parameters' dictionary.</p> <p></p>"},{"location":"api_reference/#get_phantom_definition","title":"get_phantom_definition","text":"<pre><code>def get_phantom_definition(phantom_name: str) -&gt; dict\n</code></pre> <p>Gets the configuration for a specific phantom.</p> <p>Arguments:</p> <ul> <li><code>phantom_name</code> - The name of the phantom.</li> </ul> <p>Returns:</p> <p>The configuration for the specified phantom.</p> <p></p>"},{"location":"api_reference/#get_material_mapping","title":"get_material_mapping","text":"<pre><code>def get_material_mapping(phantom_name: str) -&gt; dict\n</code></pre> <p>Gets the material name mapping for a specific phantom.</p> <p>Arguments:</p> <ul> <li><code>phantom_name</code> - The name of the phantom.</li> </ul> <p>Returns:</p> <p>The material mapping dictionary.</p> <p></p>"},{"location":"api_reference/#get_solver_settings","title":"get_solver_settings","text":"<pre><code>def get_solver_settings() -&gt; dict\n</code></pre> <p>Gets the 'solver_settings' dictionary.</p> <p></p>"},{"location":"api_reference/#get_antenna_component_names","title":"get_antenna_component_names","text":"<pre><code>def get_antenna_component_names(antenna_model_type: str) -&gt; list\n</code></pre> <p>Gets component names for a specific antenna model type.</p> <p>Arguments:</p> <ul> <li><code>antenna_model_type</code> - The type of the antenna model (e.g., 'PIFA').</li> </ul> <p>Returns:</p> <p>A list of component names.</p> <p></p>"},{"location":"api_reference/#get_manual_isolve","title":"get_manual_isolve","text":"<pre><code>def get_manual_isolve() -&gt; bool\n</code></pre> <p>Gets the 'manual_isolve' boolean flag.</p> <p></p>"},{"location":"api_reference/#get_freespace_expansion","title":"get_freespace_expansion","text":"<pre><code>def get_freespace_expansion() -&gt; list\n</code></pre> <p>Gets the freespace antenna bounding box expansion in millimeters.</p> <p></p>"},{"location":"api_reference/#get_excitation_type","title":"get_excitation_type","text":"<pre><code>def get_excitation_type() -&gt; str\n</code></pre> <p>Gets the simulation excitation type (e.g., 'Harmonic', 'Gaussian').</p> <p></p>"},{"location":"api_reference/#get_bandwidth","title":"get_bandwidth","text":"<pre><code>def get_bandwidth() -&gt; float\n</code></pre> <p>Gets the simulation bandwidth in MHz for Gaussian excitation.</p> <p></p>"},{"location":"api_reference/#get_placement_scenario","title":"get_placement_scenario","text":"<pre><code>def get_placement_scenario(scenario_name: str) -&gt; dict\n</code></pre> <p>Gets the definition for a specific placement scenario.</p> <p>Arguments:</p> <ul> <li><code>scenario_name</code> - The name of the placement scenario.</li> </ul> <p>Returns:</p> <p>The configuration for the placement scenario.</p> <p></p>"},{"location":"api_reference/#get_profiling_config","title":"get_profiling_config","text":"<pre><code>def get_profiling_config(study_type: str) -&gt; dict\n</code></pre> <p>Gets the profiling configuration for a given study type.</p> <p>Arguments:</p> <ul> <li><code>study_type</code> - The type of the study (e.g., 'near_field').</li> </ul> <p>Returns:</p> <p>The profiling configuration for the study type.</p> <p></p>"},{"location":"api_reference/#get_line_profiling_config","title":"get_line_profiling_config","text":"<pre><code>def get_line_profiling_config() -&gt; dict\n</code></pre> <p>Gets the 'line_profiling' settings.</p> <p></p>"},{"location":"api_reference/#get_download_email","title":"get_download_email","text":"<pre><code>def get_download_email() -&gt; str\n</code></pre> <p>Gets the download email from environment variables.</p> <p></p>"},{"location":"api_reference/#get_osparc_credentials","title":"get_osparc_credentials","text":"<pre><code>def get_osparc_credentials() -&gt; dict\n</code></pre> <p>Gets oSPARC credentials from environment variables.</p> <p>Raises:</p> <ul> <li><code>ValueError</code> - If required oSPARC credentials are not set.</li> </ul> <p>Returns:</p> <p>A dictionary containing oSPARC API credentials.</p> <p></p>"},{"location":"api_reference/#get_only_write_input_file","title":"get_only_write_input_file","text":"<pre><code>def get_only_write_input_file() -&gt; bool\n</code></pre> <p>Gets the 'only_write_input_file' flag from 'execution_control'.</p> <p></p>"},{"location":"api_reference/#get_auto_cleanup_previous_results","title":"get_auto_cleanup_previous_results","text":"<pre><code>def get_auto_cleanup_previous_results() -&gt; list\n</code></pre> <p>Gets the 'auto_cleanup_previous_results' setting from 'execution_control'.</p> <p>This setting determines which previous simulation files to automatically delete to preserve disk space. It should only be used in serial workflows.</p> <p>Returns:</p> <p>A list of file types to clean up (e.g., [\"output\", \"input\"]).</p> <p></p>"},{"location":"api_reference/#module-data_extractor","title":"Module data_extractor","text":""},{"location":"api_reference/#get_parameter_from_json","title":"get_parameter_from_json","text":"<pre><code>def get_parameter_from_json(file_path: str, json_path: str) -&gt; Any\n</code></pre> <p>Extracts a nested parameter from a JSON file using a dot-separated path.</p> <p>Arguments:</p> <ul> <li><code>file_path</code> - The path to the JSON file.</li> <li><code>json_path</code> - The dot-separated path to the nested key.</li> </ul> <p>Returns:</p> <p>The value found at the specified path, or None if not found.</p> <p></p>"},{"location":"api_reference/#get_parameter","title":"get_parameter","text":"<pre><code>def get_parameter(source_config: Dict[str, Any], context: Dict[str,\n                                                               Any]) -&gt; Any\n</code></pre> <p>Retrieves a parameter from a data source based on a configuration.</p> <p>This function uses a <code>source_config</code> to determine the data source type (e.g., 'json') and access parameters. The <code>context</code> dictionary provides dynamic values for formatting file paths.</p> <p>Arguments:</p> <ul> <li><code>source_config</code> - A dictionary defining the data source.</li> <li><code>context</code> - A dictionary with contextual information for formatting.</li> </ul> <p>Returns:</p> <p>The retrieved parameter value, or None on error.</p> <p></p>"},{"location":"api_reference/#module-gui_manager","title":"Module gui_manager","text":""},{"location":"api_reference/#queuegui","title":"QueueGUI","text":"<pre><code>class QueueGUI(LoggingMixin)\n</code></pre> <p>A proxy for the main GUI, designed to operate in a separate process.</p> <p>This class mimics the <code>ProgressGUI</code> interface but directs all calls to a <code>multiprocessing.Queue</code>, allowing a worker process to send thread-safe updates to the main GUI process.</p> <p></p>"},{"location":"api_reference/#__init___2","title":"__init__","text":"<pre><code>def __init__(queue: \"Queue\", stop_event: \"Event\", profiler: \"Profiler\",\n             progress_logger: \"Logger\", verbose_logger: \"Logger\")\n</code></pre> <p>Initializes the QueueGUI proxy.</p> <p>Arguments:</p> <ul> <li><code>queue</code> - The queue for inter-process communication.</li> <li><code>stop_event</code> - An event to signal termination.</li> <li><code>profiler</code> - The profiler instance for ETA calculations.</li> <li><code>progress_logger</code> - Logger for progress messages.</li> <li><code>verbose_logger</code> - Logger for detailed messages.</li> </ul> <p></p>"},{"location":"api_reference/#log","title":"log","text":"<pre><code>def log(message: str, level: str = \"verbose\", log_type: str = \"default\")\n</code></pre> <p>Sends a log message to the main GUI process via the queue.</p> <p></p>"},{"location":"api_reference/#update_overall_progress","title":"update_overall_progress","text":"<pre><code>def update_overall_progress(current_step: int, total_steps: int)\n</code></pre> <p>Sends an overall progress update to the queue.</p> <p></p>"},{"location":"api_reference/#update_stage_progress","title":"update_stage_progress","text":"<pre><code>def update_stage_progress(stage_name: str, current_step: int,\n                          total_steps: int)\n</code></pre> <p>Sends a stage-specific progress update to the queue.</p> <p></p>"},{"location":"api_reference/#start_stage_animation","title":"start_stage_animation","text":"<pre><code>def start_stage_animation(task_name: str, end_value: int)\n</code></pre> <p>Sends a command to start a progress bar animation.</p> <p></p>"},{"location":"api_reference/#end_stage_animation","title":"end_stage_animation","text":"<pre><code>def end_stage_animation()\n</code></pre> <p>Sends a command to stop the progress bar animation.</p> <p></p>"},{"location":"api_reference/#update_profiler","title":"update_profiler","text":"<pre><code>def update_profiler()\n</code></pre> <p>Sends the updated profiler object to the GUI process.</p> <p></p>"},{"location":"api_reference/#process_events","title":"process_events","text":"<pre><code>def process_events()\n</code></pre> <p>A no-op method for interface compatibility.</p> <p></p>"},{"location":"api_reference/#is_stopped","title":"is_stopped","text":"<pre><code>def is_stopped() -&gt; bool\n</code></pre> <p>Checks if the main process has signaled a stop request.</p> <p></p>"},{"location":"api_reference/#progressgui","title":"ProgressGUI","text":"<pre><code>class ProgressGUI(QWidget)\n</code></pre> <p>The main GUI for monitoring simulation progress.</p> <p>Provides a real-time view of the study's progress, including progress bars, ETA, and a log of status messages. It runs in the main process and communicates with the worker process via a multiprocessing queue.</p> <p></p>"},{"location":"api_reference/#__init___3","title":"__init__","text":"<pre><code>def __init__(queue: \"Queue\",\n             stop_event: \"Event\",\n             process,\n             window_title: str = \"Simulation Progress\")\n</code></pre> <p>Initializes the ProgressGUI window.</p> <p>Arguments:</p> <ul> <li><code>queue</code> - The queue for receiving messages from the worker process.</li> <li><code>stop_event</code> - An event to signal termination to the worker process.</li> <li><code>process</code> - The worker process running the study.</li> <li><code>window_title</code> - The title of the GUI window.</li> </ul> <p></p>"},{"location":"api_reference/#init_ui","title":"init_ui","text":"<pre><code>def init_ui()\n</code></pre> <p>Initializes and arranges all UI widgets.</p> <p></p>"},{"location":"api_reference/#process_queue","title":"process_queue","text":"<pre><code>def process_queue()\n</code></pre> <p>Processes messages from the worker process queue to update the UI.</p> <p></p>"},{"location":"api_reference/#tray_icon_activated","title":"tray_icon_activated","text":"<pre><code>def tray_icon_activated(reason)\n</code></pre> <p>Handles activation of the system tray icon.</p> <p></p>"},{"location":"api_reference/#hide_to_tray","title":"hide_to_tray","text":"<pre><code>def hide_to_tray()\n</code></pre> <p>Hides the main window and shows the system tray icon.</p> <p></p>"},{"location":"api_reference/#show_from_tray","title":"show_from_tray","text":"<pre><code>def show_from_tray()\n</code></pre> <p>Shows the main window from the system tray.</p> <p></p>"},{"location":"api_reference/#stop_study","title":"stop_study","text":"<pre><code>def stop_study()\n</code></pre> <p>Sends a stop signal to the worker process.</p> <p></p>"},{"location":"api_reference/#update_overall_progress_1","title":"update_overall_progress","text":"<pre><code>def update_overall_progress(current_step: int, total_steps: int)\n</code></pre> <p>Updates the overall progress bar.</p> <p></p>"},{"location":"api_reference/#update_stage_progress_1","title":"update_stage_progress","text":"<pre><code>def update_stage_progress(stage_name: str, current_step: int,\n                          total_steps: int)\n</code></pre> <p>Updates the stage-specific progress bar.</p> <p></p>"},{"location":"api_reference/#start_stage_animation_1","title":"start_stage_animation","text":"<pre><code>def start_stage_animation(estimated_duration: float, end_step: int)\n</code></pre> <p>Starts a smooth animation for the stage progress bar.</p> <p>Arguments:</p> <ul> <li><code>estimated_duration</code> - The estimated time in seconds for the task.</li> <li><code>end_step</code> - The target step value for the animation.</li> </ul> <p></p>"},{"location":"api_reference/#end_stage_animation_1","title":"end_stage_animation","text":"<pre><code>def end_stage_animation()\n</code></pre> <p>Stops the stage progress bar animation.</p> <p></p>"},{"location":"api_reference/#update_animation","title":"update_animation","text":"<pre><code>def update_animation()\n</code></pre> <p>Updates the progress bar animation frame by frame.</p> <p></p>"},{"location":"api_reference/#update_status","title":"update_status","text":"<pre><code>def update_status(message: str, log_type: str = \"default\")\n</code></pre> <p>Appends a message to the status log text box.</p> <p></p>"},{"location":"api_reference/#update_clock","title":"update_clock","text":"<pre><code>def update_clock()\n</code></pre> <p>Updates the elapsed time and ETA labels.</p> <p></p>"},{"location":"api_reference/#study_finished","title":"study_finished","text":"<pre><code>def study_finished(error: bool = False)\n</code></pre> <p>Handles study completion, stopping timers and updating the UI.</p> <p></p>"},{"location":"api_reference/#closeevent","title":"closeEvent","text":"<pre><code>def closeEvent(event)\n</code></pre> <p>Handles the window close event, ensuring worker process termination.</p> <p></p>"},{"location":"api_reference/#module-logging_manager","title":"Module logging_manager","text":""},{"location":"api_reference/#colorformatter","title":"ColorFormatter","text":"<pre><code>class ColorFormatter(logging.Formatter)\n</code></pre> <p>A custom log formatter that applies color to terminal output.</p> <p></p>"},{"location":"api_reference/#format","title":"format","text":"<pre><code>def format(record: logging.LogRecord) -&gt; str\n</code></pre> <p>Formats the log record by adding color codes.</p> <p>Arguments:</p> <ul> <li><code>record</code> - The log record to format.</li> </ul> <p>Returns:</p> <p>The formatted and colorized log message.</p> <p></p>"},{"location":"api_reference/#setup_loggers","title":"setup_loggers","text":"<pre><code>def setup_loggers(\n        process_id: str = None) -&gt; tuple[logging.Logger, logging.Logger, str]\n</code></pre> <p>Initializes and configures the dual-logging system.</p> <p>Sets up two loggers: 1. 'progress': For high-level, user-facing updates. 2. 'verbose': For detailed, internal debugging information.</p> <p>Also handles log rotation to prevent excessive disk usage.</p> <p>Arguments:</p> <ul> <li><code>process_id</code> - An identifier for the process to ensure unique log   filenames in parallel runs.</li> </ul> <p>Returns:</p> <p>A tuple containing the progress logger, verbose logger, and the   session timestamp.</p> <p></p>"},{"location":"api_reference/#shutdown_loggers","title":"shutdown_loggers","text":"<pre><code>def shutdown_loggers()\n</code></pre> <p>Safely shuts down all logging handlers to release file locks.</p> <p></p>"},{"location":"api_reference/#loggingmixin","title":"LoggingMixin","text":"<pre><code>class LoggingMixin()\n</code></pre> <p>A mixin class that provides a standardized logging interface.</p> <p>Provides a <code>_log</code> method that directs messages to the appropriate logger ('progress' or 'verbose') and, if available, to the GUI.</p> <p></p>"},{"location":"api_reference/#module-profiler","title":"Module profiler","text":""},{"location":"api_reference/#profiler","title":"Profiler","text":"<pre><code>class Profiler()\n</code></pre> <p>Manages execution time tracking, ETA estimation, and study phase management.</p> <p>This class divides a study into phases (setup, run, extract), calculates weighted progress, and estimates the time remaining. It also saves updated time estimates to a configuration file after each run, making it self-improving.</p> <p></p>"},{"location":"api_reference/#__init___4","title":"__init__","text":"<pre><code>def __init__(execution_control: dict, profiling_config: dict, study_type: str,\n             config_path: str)\n</code></pre> <p>Initializes the Profiler.</p> <p>Arguments:</p> <ul> <li><code>execution_control</code> - A dictionary indicating which study phases are active.</li> <li><code>profiling_config</code> - A dictionary with historical timing data.</li> <li><code>study_type</code> - The type of the study (e.g., 'near_field').</li> <li><code>config_path</code> - The file path to the profiling configuration.</li> </ul> <p></p>"},{"location":"api_reference/#set_total_simulations","title":"set_total_simulations","text":"<pre><code>def set_total_simulations(total: int)\n</code></pre> <p>Sets the total number of simulations for the study.</p> <p></p>"},{"location":"api_reference/#set_project_scope","title":"set_project_scope","text":"<pre><code>def set_project_scope(total_projects: int)\n</code></pre> <p>Sets the total number of projects to be processed.</p> <p></p>"},{"location":"api_reference/#set_current_project","title":"set_current_project","text":"<pre><code>def set_current_project(project_index: int)\n</code></pre> <p>Sets the index of the currently processing project.</p> <p></p>"},{"location":"api_reference/#start_stage","title":"start_stage","text":"<pre><code>def start_stage(phase_name: str, total_stages: int = 1)\n</code></pre> <p>Marks the beginning of a new study phase or stage.</p> <p>Arguments:</p> <ul> <li><code>phase_name</code> - The name of the phase being started.</li> <li><code>total_stages</code> - The total number of stages within this phase.</li> </ul> <p></p>"},{"location":"api_reference/#end_stage","title":"end_stage","text":"<pre><code>def end_stage()\n</code></pre> <p>Marks the end of a study phase and records its duration.</p> <p></p>"},{"location":"api_reference/#complete_run_phase","title":"complete_run_phase","text":"<pre><code>def complete_run_phase()\n</code></pre> <p>Stores the total duration of the 'run' phase from its subtasks.</p> <p></p>"},{"location":"api_reference/#get_weighted_progress","title":"get_weighted_progress","text":"<pre><code>def get_weighted_progress(phase_name: str,\n                          phase_progress_ratio: float) -&gt; float\n</code></pre> <p>Calculates the overall study progress based on phase weights.</p> <p>Arguments:</p> <ul> <li><code>phase_name</code> - The name of the current phase.</li> <li><code>phase_progress_ratio</code> - The progress of the current phase (0.0 to 1.0).</li> </ul> <p>Returns:</p> <p>The total weighted progress percentage.</p> <p></p>"},{"location":"api_reference/#get_subtask_estimate","title":"get_subtask_estimate","text":"<pre><code>def get_subtask_estimate(task_name: str) -&gt; float\n</code></pre> <p>Retrieves the estimated time for a specific subtask.</p> <p>Arguments:</p> <ul> <li><code>task_name</code> - The name of the subtask.</li> </ul> <p>Returns:</p> <p>The estimated duration in seconds.</p> <p></p>"},{"location":"api_reference/#get_time_remaining","title":"get_time_remaining","text":"<pre><code>def get_time_remaining(current_stage_progress: float = 0.0) -&gt; float\n</code></pre> <p>Estimates the total time remaining for the study.</p> <p>This considers completed phases, current phase progress, and estimated time for all future phases.</p> <p>Arguments:</p> <ul> <li><code>current_stage_progress</code> - The progress of the current stage (0.0 to 1.0).</li> </ul> <p>Returns:</p> <p>The estimated time remaining in seconds.</p> <p></p>"},{"location":"api_reference/#update_and_save_estimates","title":"update_and_save_estimates","text":"<pre><code>def update_and_save_estimates()\n</code></pre> <p>Updates the profiling configuration with the latest average times and saves it.</p> <p>This makes the profiler's estimates self-improving over time.</p> <p></p>"},{"location":"api_reference/#save_estimates","title":"save_estimates","text":"<pre><code>def save_estimates()\n</code></pre> <p>Saves the final profiling estimates at the end of the study.</p> <p></p>"},{"location":"api_reference/#module-project_manager","title":"Module project_manager","text":""},{"location":"api_reference/#projectcorruptionerror","title":"ProjectCorruptionError","text":"<pre><code>class ProjectCorruptionError(Exception)\n</code></pre> <p>Custom exception raised for errors related to corrupted or locked project files.</p> <p></p>"},{"location":"api_reference/#projectmanager","title":"ProjectManager","text":"<pre><code>class ProjectManager(LoggingMixin)\n</code></pre> <p>Manages the lifecycle of Sim4Life (.smash) project files.</p> <p>Handles creation, opening, saving, and validation of project files, ensuring robustness against file corruption and locks.</p> <p></p>"},{"location":"api_reference/#__init___5","title":"__init__","text":"<pre><code>def __init__(config: \"Config\",\n             verbose_logger: \"Logger\",\n             progress_logger: \"Logger\",\n             gui: \"QueueGUI\" = None)\n</code></pre> <p>Initializes the ProjectManager.</p> <p>Arguments:</p> <ul> <li><code>config</code> - The main configuration object.</li> <li><code>verbose_logger</code> - Logger for detailed output.</li> <li><code>progress_logger</code> - Logger for high-level progress updates.</li> <li><code>gui</code> - The GUI proxy for inter-process communication.</li> </ul> <p></p>"},{"location":"api_reference/#create_or_open_project","title":"create_or_open_project","text":"<pre><code>def create_or_open_project(phantom_name: str,\n                           frequency_mhz: int,\n                           scenario_name: str = None,\n                           position_name: str = None,\n                           orientation_name: str = None)\n</code></pre> <p>Creates a new project or opens an existing one based on the 'do_setup' flag.</p> <p>Arguments:</p> <ul> <li><code>phantom_name</code> - The name of the phantom model.</li> <li><code>frequency_mhz</code> - The simulation frequency in MHz.</li> <li><code>scenario_name</code> - The base name of the placement scenario.</li> <li><code>position_name</code> - The name of the position within the scenario.</li> <li><code>orientation_name</code> - The name of the orientation within the scenario.</li> </ul> <p>Raises:</p> <ul> <li><code>ValueError</code> - If required parameters are missing or <code>study_type</code> is unknown.</li> <li><code>FileNotFoundError</code> - If <code>do_setup</code> is false and the project file does not exist.</li> <li><code>ProjectCorruptionError</code> - If the project file is corrupted.</li> </ul> <p></p>"},{"location":"api_reference/#create_new","title":"create_new","text":"<pre><code>def create_new()\n</code></pre> <p>Creates a new, empty project in memory.</p> <p>Closes any open document, deletes the existing project file and its cache, then creates a new unsaved project.</p> <p></p>"},{"location":"api_reference/#open","title":"open","text":"<pre><code>def open()\n</code></pre> <p>Opens an existing project after performing validation checks.</p> <p>Raises:</p> <ul> <li><code>ProjectCorruptionError</code> - If the project file is invalid, locked, or   cannot be opened by Sim4Life.</li> </ul> <p></p>"},{"location":"api_reference/#save","title":"save","text":"<pre><code>def save()\n</code></pre> <p>Saves the currently active project to its designated file path.</p> <p>Raises:</p> <ul> <li><code>ValueError</code> - If the project path has not been set.</li> </ul> <p></p>"},{"location":"api_reference/#close","title":"close","text":"<pre><code>def close()\n</code></pre> <p>Closes the currently active Sim4Life document.</p> <p></p>"},{"location":"api_reference/#cleanup","title":"cleanup","text":"<pre><code>def cleanup()\n</code></pre> <p>Closes any open project.</p> <p></p>"},{"location":"api_reference/#reload_project","title":"reload_project","text":"<pre><code>def reload_project()\n</code></pre> <p>Saves, closes, and re-opens the project to load simulation results.</p> <p></p>"},{"location":"api_reference/#module-results_extractor","title":"Module results_extractor","text":""},{"location":"api_reference/#resultsextractor","title":"ResultsExtractor","text":"<pre><code>class ResultsExtractor(LoggingMixin)\n</code></pre> <p>Orchestrates post-processing and data extraction from simulation results.</p> <p>Coordinates modules to extract power, SAR, and sensor data from a Sim4Life simulation, then manages report generation and cleanup.</p> <p></p>"},{"location":"api_reference/#__init___6","title":"__init__","text":"<pre><code>def __init__(config: \"Config\",\n             simulation: \"s4l_v1.simulation.emfdtd.Simulation\",\n             phantom_name: str,\n             frequency_mhz: int,\n             scenario_name: str,\n             position_name: str,\n             orientation_name: str,\n             study_type: str,\n             verbose_logger: \"Logger\",\n             progress_logger: \"Logger\",\n             free_space: bool = False,\n             gui: \"QueueGUI\" = None,\n             study: \"BaseStudy\" = None)\n</code></pre> <p>Initializes the ResultsExtractor.</p> <p>Arguments:</p> <ul> <li><code>config</code> - The configuration object for the study.</li> <li><code>simulation</code> - The simulation object to extract results from.</li> <li><code>phantom_name</code> - The name of the phantom model used.</li> <li><code>frequency_mhz</code> - The simulation frequency in MHz.</li> <li><code>scenario_name</code> - The base name of the placement scenario.</li> <li><code>position_name</code> - The name of the position within the scenario.</li> <li><code>orientation_name</code> - The name of the orientation within the scenario.</li> <li><code>study_type</code> - The type of the study (e.g., 'near_field').</li> <li><code>verbose_logger</code> - Logger for detailed output.</li> <li><code>progress_logger</code> - Logger for progress updates.</li> <li><code>free_space</code> - Flag indicating if the simulation was run in free space.</li> <li><code>gui</code> - The GUI proxy for updates.</li> <li><code>study</code> - The parent study object.</li> </ul> <p></p>"},{"location":"api_reference/#extract","title":"extract","text":"<pre><code>def extract()\n</code></pre> <p>Orchestrates the extraction of all relevant data from the simulation.</p> <p>This is the main entry point for the class. It coordinates extraction modules for power, SAR, and sensor data, then saves the results.</p> <p></p>"},{"location":"api_reference/#module-simulation_runner","title":"Module simulation_runner","text":""},{"location":"api_reference/#simulationrunner","title":"SimulationRunner","text":"<pre><code>class SimulationRunner(LoggingMixin)\n</code></pre> <p>Manages simulation execution via the Sim4Life API or iSolve.exe.</p> <p></p>"},{"location":"api_reference/#__init___7","title":"__init__","text":"<pre><code>def __init__(config: \"Config\",\n             project_path: str,\n             simulations: Union[\"s4l_v1.simulation.emfdtd.Simulation\",\n                                List[\"s4l_v1.simulation.emfdtd.Simulation\"]],\n             verbose_logger: \"Logger\",\n             progress_logger: \"Logger\",\n             gui: \"QueueGUI\" = None,\n             study: \"BaseStudy\" = None)\n</code></pre> <p>Initializes the SimulationRunner.</p> <p>Arguments:</p> <ul> <li><code>config</code> - The configuration object for the study.</li> <li><code>project_path</code> - The file path to the Sim4Life project.</li> <li><code>simulations</code> - A single simulation or a list of simulations to run.</li> <li><code>verbose_logger</code> - Logger for detailed, verbose output.</li> <li><code>progress_logger</code> - Logger for high-level progress updates.</li> <li><code>gui</code> - The GUI proxy for sending updates to the main process.</li> <li><code>study</code> - The parent study object for profiling and context.</li> </ul> <p></p>"},{"location":"api_reference/#run_all","title":"run_all","text":"<pre><code>def run_all()\n</code></pre> <p>Runs all simulations in the list, managing GUI animations.</p> <p></p>"},{"location":"api_reference/#run","title":"run","text":"<pre><code>def run(simulation: \"s4l_v1.simulation.emfdtd.Simulation\")\n</code></pre> <p>Runs a single simulation, wrapped in a subtask for timing.</p> <p></p>"},{"location":"api_reference/#module-utils","title":"Module utils","text":""},{"location":"api_reference/#studycancellederror","title":"StudyCancelledError","text":"<pre><code>class StudyCancelledError(Exception)\n</code></pre> <p>Custom exception to indicate that the study was cancelled by the user.</p> <p></p>"},{"location":"api_reference/#profiler_1","title":"Profiler","text":"<pre><code>class Profiler()\n</code></pre> <p>A simple profiler to track and estimate execution time for a series of runs.</p> <p></p>"},{"location":"api_reference/#__init___8","title":"__init__","text":"<pre><code>def __init__(config_path: str, study_type: str = \"sensitivity_analysis\")\n</code></pre> <p>Initializes the simple Profiler.</p> <p>Arguments:</p> <ul> <li><code>config_path</code> - The file path to the profiling configuration JSON.</li> <li><code>study_type</code> - The key for the study-specific configuration.</li> </ul> <p></p>"},{"location":"api_reference/#start_study","title":"start_study","text":"<pre><code>def start_study(total_runs: int)\n</code></pre> <p>Starts a new study, resetting counters.</p> <p></p>"},{"location":"api_reference/#start_run","title":"start_run","text":"<pre><code>def start_run()\n</code></pre> <p>Marks the beginning of a single run.</p> <p></p>"},{"location":"api_reference/#end_run","title":"end_run","text":"<pre><code>def end_run()\n</code></pre> <p>Marks the end of a single run and records its duration.</p> <p></p>"},{"location":"api_reference/#get_average_run_time","title":"get_average_run_time","text":"<pre><code>def get_average_run_time() -&gt; float\n</code></pre> <p>Gets the average run time, prioritizing measured times over historical estimates.</p> <p></p>"},{"location":"api_reference/#get_time_remaining_1","title":"get_time_remaining","text":"<pre><code>def get_time_remaining() -&gt; float\n</code></pre> <p>Estimates the time remaining for the entire study.</p> <p></p>"},{"location":"api_reference/#save_estimates_1","title":"save_estimates","text":"<pre><code>def save_estimates()\n</code></pre> <p>Saves the new average run time to the configuration file.</p> <p></p>"},{"location":"api_reference/#get_elapsed","title":"get_elapsed","text":"<pre><code>def get_elapsed() -&gt; float\n</code></pre> <p>Gets the total elapsed time since the study started.</p> <p>Returns:</p> <p>The elapsed time in seconds.</p> <p></p>"},{"location":"api_reference/#subtask","title":"subtask","text":"<pre><code>@contextlib.contextmanager\ndef subtask(name: str)\n</code></pre> <p>A context manager to time a subtask.</p> <p></p>"},{"location":"api_reference/#format_time","title":"format_time","text":"<pre><code>def format_time(seconds: float) -&gt; str\n</code></pre> <p>Formats seconds into a human-readable string (e.g., 1m 23s).</p> <p></p>"},{"location":"api_reference/#non_blocking_sleep","title":"non_blocking_sleep","text":"<pre><code>def non_blocking_sleep(seconds: int)\n</code></pre> <p>A non-blocking sleep that processes GUI events.</p> <p></p>"},{"location":"api_reference/#profile","title":"profile","text":"<pre><code>@contextlib.contextmanager\ndef profile(study: \"BaseStudy\", phase_name: str)\n</code></pre> <p>A context manager to profile a block of code (a 'phase').</p> <p></p>"},{"location":"api_reference/#profile_subtask","title":"profile_subtask","text":"<pre><code>@contextlib.contextmanager\ndef profile_subtask(study: \"BaseStudy\",\n                    task_name: str,\n                    instance_to_profile=None)\n</code></pre> <p>A context manager for a 'subtask'.</p> <p>Handles: - High-level timing via study.profiler. - GUI stage animation. - Optional, detailed line-by-line profiling if configured.</p> <p></p>"},{"location":"api_reference/#ensure_s4l_running","title":"ensure_s4l_running","text":"<pre><code>def ensure_s4l_running()\n</code></pre> <p>Ensures that the Sim4Life application is running.</p> <p></p>"},{"location":"api_reference/#open_project","title":"open_project","text":"<pre><code>def open_project(project_path: str)\n</code></pre> <p>Opens a Sim4Life project or creates a new one in memory.</p> <p></p>"},{"location":"api_reference/#delete_project_file","title":"delete_project_file","text":"<pre><code>def delete_project_file(project_path: str)\n</code></pre> <p>Deletes the project file if it exists.</p> <p></p>"},{"location":"api_reference/#suppress_stdout_stderr","title":"suppress_stdout_stderr","text":"<pre><code>@contextlib.contextmanager\ndef suppress_stdout_stderr()\n</code></pre> <p>A context manager that redirects stdout and stderr to devnull.</p> <p></p>"},{"location":"api_reference/#module-srcanalysisanalyzer","title":"Module src.analysis.analyzer","text":""},{"location":"api_reference/#analyzer","title":"Analyzer","text":"<pre><code>class Analyzer()\n</code></pre> <p>Analyzes simulation results using a strategy pattern.</p> <p></p>"},{"location":"api_reference/#__init___9","title":"__init__","text":"<pre><code>def __init__(config: \"Config\", phantom_name: str,\n             strategy: \"BaseAnalysisStrategy\")\n</code></pre> <p>Initializes the Analyzer.</p> <p>Arguments:</p> <ul> <li><code>config</code> - The configuration object for the study.</li> <li><code>phantom_name</code> - The name of the phantom model being analyzed.</li> <li><code>strategy</code> - The analysis strategy to use.</li> </ul> <p></p>"},{"location":"api_reference/#run_analysis","title":"run_analysis","text":"<pre><code>def run_analysis()\n</code></pre> <p>Runs the full analysis pipeline using the selected strategy.</p> <p></p>"},{"location":"api_reference/#module-srcanalysisbase_strategy","title":"Module src.analysis.base_strategy","text":""},{"location":"api_reference/#baseanalysisstrategy","title":"BaseAnalysisStrategy","text":"<pre><code>class BaseAnalysisStrategy(ABC)\n</code></pre> <p>Abstract base class for analysis strategies.</p> <p></p>"},{"location":"api_reference/#__init___10","title":"__init__","text":"<pre><code>def __init__(config: \"Config\", phantom_name: str)\n</code></pre> <p>Initializes the analysis strategy.</p> <p>Arguments:</p> <ul> <li><code>config</code> - The main configuration object.</li> <li><code>phantom_name</code> - The name of the phantom being analyzed.</li> </ul> <p></p>"},{"location":"api_reference/#get_results_base_dir","title":"get_results_base_dir","text":"<pre><code>@abstractmethod\ndef get_results_base_dir() -&gt; str\n</code></pre> <p>Gets the base directory for results.</p> <p></p>"},{"location":"api_reference/#get_plots_dir","title":"get_plots_dir","text":"<pre><code>@abstractmethod\ndef get_plots_dir() -&gt; str\n</code></pre> <p>Gets the directory for saving plots.</p> <p></p>"},{"location":"api_reference/#load_and_process_results","title":"load_and_process_results","text":"<pre><code>@abstractmethod\ndef load_and_process_results(analyzer: \"Analyzer\")\n</code></pre> <p>Loads and processes all relevant simulation results.</p> <p>Arguments:</p> <ul> <li><code>analyzer</code> - The main analyzer instance calling the strategy.</li> </ul> <p></p>"},{"location":"api_reference/#get_normalization_factor","title":"get_normalization_factor","text":"<pre><code>@abstractmethod\ndef get_normalization_factor(frequency_mhz: int,\n                             simulated_power_w: float) -&gt; float\n</code></pre> <p>Calculates the normalization factor for SAR values.</p> <p>Arguments:</p> <ul> <li><code>frequency_mhz</code> - The simulation frequency in MHz.</li> <li><code>simulated_power_w</code> - The input power from the simulation in Watts.</li> </ul> <p>Returns:</p> <p>The calculated normalization factor.</p> <p></p>"},{"location":"api_reference/#extract_data","title":"extract_data","text":"<pre><code>@abstractmethod\ndef extract_data(pickle_data: dict, frequency_mhz: int, detailed_name: str,\n                 scenario_name: str, sim_power: float,\n                 norm_factor: float) -&gt; tuple[dict, list]\n</code></pre> <p>Extracts and structures data from a single simulation's result files.</p> <p>Arguments:</p> <ul> <li><code>pickle_data</code> - Data loaded from the .pkl result file.</li> <li><code>frequency_mhz</code> - The simulation frequency.</li> <li><code>detailed_name</code> - The detailed name of the placement or scenario.</li> <li><code>scenario_name</code> - The general scenario name.</li> <li><code>sim_power</code> - The simulated input power in Watts.</li> <li><code>norm_factor</code> - The normalization factor to apply.</li> </ul> <p>Returns:</p> <p>A tuple containing the main result entry and a list of organ-specific entries.</p> <p></p>"},{"location":"api_reference/#apply_bug_fixes","title":"apply_bug_fixes","text":"<pre><code>@abstractmethod\ndef apply_bug_fixes(result_entry: dict) -&gt; dict\n</code></pre> <p>Applies workarounds for known data inconsistencies.</p> <p>Arguments:</p> <ul> <li><code>result_entry</code> - The data entry for a single simulation result.</li> </ul> <p>Returns:</p> <p>The corrected result entry.</p> <p></p>"},{"location":"api_reference/#calculate_summary_stats","title":"calculate_summary_stats","text":"<pre><code>@abstractmethod\ndef calculate_summary_stats(results_df: pd.DataFrame) -&gt; pd.DataFrame\n</code></pre> <p>Calculates summary statistics from the aggregated results.</p> <p>Arguments:</p> <ul> <li><code>results_df</code> - DataFrame with all aggregated simulation results.</li> </ul> <p>Returns:</p> <p>A DataFrame with summary statistics.</p> <p></p>"},{"location":"api_reference/#generate_plots","title":"generate_plots","text":"<pre><code>@abstractmethod\ndef generate_plots(analyzer: \"Analyzer\", plotter: \"Plotter\",\n                   results_df: pd.DataFrame,\n                   all_organ_results_df: pd.DataFrame)\n</code></pre> <p>Generates all plots relevant to this analysis strategy.</p> <p>Arguments:</p> <ul> <li><code>analyzer</code> - The main analyzer instance.</li> <li><code>plotter</code> - The plotter instance to use for generating plots.</li> <li><code>results_df</code> - DataFrame with main aggregated results.</li> <li><code>all_organ_results_df</code> - DataFrame with detailed organ-level results.</li> </ul> <p></p>"},{"location":"api_reference/#module-srcanalysisfar_field_strategy","title":"Module src.analysis.far_field_strategy","text":""},{"location":"api_reference/#farfieldanalysisstrategy","title":"FarFieldAnalysisStrategy","text":"<pre><code>class FarFieldAnalysisStrategy(BaseAnalysisStrategy)\n</code></pre> <p>Analysis strategy for far-field simulations.</p> <p></p>"},{"location":"api_reference/#get_results_base_dir_1","title":"get_results_base_dir","text":"<pre><code>def get_results_base_dir() -&gt; str\n</code></pre> <p>Gets the base directory for far-field results.</p> <p></p>"},{"location":"api_reference/#get_plots_dir_1","title":"get_plots_dir","text":"<pre><code>def get_plots_dir() -&gt; str\n</code></pre> <p>Gets the directory for saving far-field plots.</p> <p></p>"},{"location":"api_reference/#get_normalization_factor_1","title":"get_normalization_factor","text":"<pre><code>def get_normalization_factor(frequency_mhz: int,\n                             simulated_power_w: float) -&gt; float\n</code></pre> <p>Returns the normalization factor for far-field analysis (always 1.0).</p> <p></p>"},{"location":"api_reference/#apply_bug_fixes_1","title":"apply_bug_fixes","text":"<pre><code>def apply_bug_fixes(result_entry: dict) -&gt; dict\n</code></pre> <p>No bug fixes needed for far-field data.</p> <p></p>"},{"location":"api_reference/#calculate_summary_stats_1","title":"calculate_summary_stats","text":"<pre><code>def calculate_summary_stats(results_df: pd.DataFrame) -&gt; pd.DataFrame\n</code></pre> <p>Calculates summary statistics for far-field results.</p> <p></p>"},{"location":"api_reference/#module-srcanalysisnear_field_strategy","title":"Module src.analysis.near_field_strategy","text":""},{"location":"api_reference/#nearfieldanalysisstrategy","title":"NearFieldAnalysisStrategy","text":"<pre><code>class NearFieldAnalysisStrategy(BaseAnalysisStrategy)\n</code></pre> <p>Analysis strategy for near-field simulations.</p> <p></p>"},{"location":"api_reference/#get_results_base_dir_2","title":"get_results_base_dir","text":"<pre><code>def get_results_base_dir() -&gt; str\n</code></pre> <p>Gets the base directory for near-field results.</p> <p></p>"},{"location":"api_reference/#get_plots_dir_2","title":"get_plots_dir","text":"<pre><code>def get_plots_dir() -&gt; str\n</code></pre> <p>Gets the directory for saving near-field plots.</p> <p></p>"},{"location":"api_reference/#load_and_process_results_1","title":"load_and_process_results","text":"<pre><code>def load_and_process_results(analyzer: \"Analyzer\")\n</code></pre> <p>Iterates through near-field simulation results and processes each one.</p> <p></p>"},{"location":"api_reference/#get_normalization_factor_2","title":"get_normalization_factor","text":"<pre><code>def get_normalization_factor(frequency_mhz: int,\n                             simulated_power_w: float) -&gt; float\n</code></pre> <p>Calculates the normalization factor based on the target power.</p> <p>Arguments:</p> <ul> <li><code>frequency_mhz</code> - The simulation frequency in MHz.</li> <li><code>simulated_power_w</code> - The input power from the simulation in Watts.</li> </ul> <p>Returns:</p> <p>The calculated normalization factor, or 1.0 if not possible.</p> <p></p>"},{"location":"api_reference/#extract_data_1","title":"extract_data","text":"<pre><code>def extract_data(pickle_data: dict, frequency_mhz: int, placement_name: str,\n                 scenario_name: str, sim_power: float,\n                 norm_factor: float) -&gt; tuple[dict, list]\n</code></pre> <p>Extracts and normalizes SAR data from a single near-field result.</p> <p>Arguments:</p> <ul> <li><code>pickle_data</code> - Data loaded from the .pkl result file.</li> <li><code>frequency_mhz</code> - The simulation frequency.</li> <li><code>placement_name</code> - The detailed name of the placement.</li> <li><code>scenario_name</code> - The general scenario name (e.g., 'by_cheek').</li> <li><code>sim_power</code> - The simulated input power in Watts.</li> <li><code>norm_factor</code> - The normalization factor to apply to SAR values.</li> </ul> <p>Returns:</p> <p>A tuple containing the main result entry and a list of organ-specific entries.</p> <p></p>"},{"location":"api_reference/#apply_bug_fixes_2","title":"apply_bug_fixes","text":"<pre><code>def apply_bug_fixes(result_entry: dict) -&gt; dict\n</code></pre> <p>Applies a workaround for Head SAR being miscategorized as Trunk SAR.</p> <p>Arguments:</p> <ul> <li><code>result_entry</code> - The data entry for a single simulation result.</li> </ul> <p>Returns:</p> <p>The corrected result entry.</p> <p></p>"},{"location":"api_reference/#calculate_summary_stats_2","title":"calculate_summary_stats","text":"<pre><code>def calculate_summary_stats(results_df: pd.DataFrame) -&gt; pd.DataFrame\n</code></pre> <p>Calculates summary statistics, including completion progress.</p> <p>Arguments:</p> <ul> <li><code>results_df</code> - DataFrame with all aggregated simulation results.</li> </ul> <p>Returns:</p> <p>A DataFrame with mean SAR values and a 'progress' column.</p> <p></p>"},{"location":"api_reference/#generate_plots_1","title":"generate_plots","text":"<pre><code>def generate_plots(analyzer: \"Analyzer\", plotter: \"Plotter\",\n                   results_df: pd.DataFrame,\n                   all_organ_results_df: pd.DataFrame)\n</code></pre> <p>Generates all plots for the near-field analysis.</p> <p>Includes bar charts for average SAR, line plots for psSAR, and boxplots for SAR distribution.</p> <p>Arguments:</p> <ul> <li><code>analyzer</code> - The main analyzer instance.</li> <li><code>plotter</code> - The plotter instance for generating plots.</li> <li><code>results_df</code> - DataFrame with main aggregated results.</li> <li><code>all_organ_results_df</code> - DataFrame with detailed organ-level results.</li> </ul> <p></p>"},{"location":"api_reference/#module-srcanalysisplotter","title":"Module src.analysis.plotter","text":""},{"location":"api_reference/#plotter","title":"Plotter","text":"<pre><code>class Plotter()\n</code></pre> <p>Generates various plots from simulation results.</p> <p></p>"},{"location":"api_reference/#__init___11","title":"__init__","text":"<pre><code>def __init__(plots_dir: str)\n</code></pre> <p>Initializes the Plotter and creates the output directory.</p> <p>Arguments:</p> <ul> <li><code>plots_dir</code> - The directory where all generated plots will be saved.</li> </ul> <p></p>"},{"location":"api_reference/#plot_average_sar_bar","title":"plot_average_sar_bar","text":"<pre><code>def plot_average_sar_bar(scenario_name: str, avg_results: pd.DataFrame,\n                         progress_info: pd.Series)\n</code></pre> <p>Plots a bar chart of average Head and Trunk SAR per frequency.</p> <p>Arguments:</p> <ul> <li><code>scenario_name</code> - The name of the placement scenario (e.g., 'by_cheek').</li> <li><code>avg_results</code> - DataFrame with average SAR values, indexed by frequency.</li> <li><code>progress_info</code> - Series with completion progress for each frequency.</li> </ul> <p></p>"},{"location":"api_reference/#plot_whole_body_sar_bar","title":"plot_whole_body_sar_bar","text":"<pre><code>def plot_whole_body_sar_bar(avg_results: pd.DataFrame)\n</code></pre> <p>Plots a bar chart of the average Whole-Body SAR per frequency.</p> <p>Arguments:</p> <ul> <li><code>avg_results</code> - DataFrame with average SAR values, indexed by frequency.</li> </ul> <p></p>"},{"location":"api_reference/#plot_peak_sar_line","title":"plot_peak_sar_line","text":"<pre><code>def plot_peak_sar_line(summary_stats: pd.DataFrame)\n</code></pre> <p>Plots the peak SAR across frequencies for far-field.</p> <p></p>"},{"location":"api_reference/#plot_pssar_line","title":"plot_pssar_line","text":"<pre><code>def plot_pssar_line(scenario_name: str, avg_results: pd.DataFrame)\n</code></pre> <p>Plots a line chart of the average psSAR10g for different tissue groups.</p> <p>Arguments:</p> <ul> <li><code>scenario_name</code> - The name of the placement scenario.</li> <li><code>avg_results</code> - DataFrame with average psSAR10g values for various tissues.</li> </ul> <p></p>"},{"location":"api_reference/#plot_sar_distribution_boxplots","title":"plot_sar_distribution_boxplots","text":"<pre><code>def plot_sar_distribution_boxplots(scenario_name: str,\n                                   scenario_results_df: pd.DataFrame)\n</code></pre> <p>Creates boxplots to show the distribution of SAR values for each metric.</p> <p>Arguments:</p> <ul> <li><code>scenario_name</code> - The name of the placement scenario.</li> <li><code>scenario_results_df</code> - DataFrame with detailed results for the scenario.</li> </ul> <p></p>"},{"location":"api_reference/#plot_far_field_distribution_boxplot","title":"plot_far_field_distribution_boxplot","text":"<pre><code>def plot_far_field_distribution_boxplot(results_df: pd.DataFrame,\n                                        metric: str = \"SAR_whole_body\")\n</code></pre> <p>Generates a boxplot for the distribution of a given metric in far-field results.</p> <p></p>"},{"location":"api_reference/#plot_sar_heatmap","title":"plot_sar_heatmap","text":"<pre><code>def plot_sar_heatmap(organ_df: pd.DataFrame, group_df: pd.DataFrame,\n                     tissue_groups: dict)\n</code></pre> <p>Generates the combined heatmap for Min, Avg, and Max SAR.</p> <p></p>"},{"location":"api_reference/#plot_peak_sar_heatmap","title":"plot_peak_sar_heatmap","text":"<pre><code>def plot_peak_sar_heatmap(organ_df: pd.DataFrame,\n                          group_df: pd.DataFrame,\n                          tissue_groups: dict,\n                          value_col: str = \"peak_sar_10g_mw_kg\",\n                          title: str = \"Peak SAR\")\n</code></pre> <p>Generates a combined heatmap for a given peak SAR metric.</p> <p></p>"},{"location":"api_reference/#module-srcanalysisstrategies","title":"Module src.analysis.strategies","text":""},{"location":"api_reference/#baseanalysisstrategy_1","title":"BaseAnalysisStrategy","text":"<pre><code>class BaseAnalysisStrategy(ABC)\n</code></pre> <p>Abstract base class for analysis strategies.</p> <p></p>"},{"location":"api_reference/#__init___12","title":"__init__","text":"<pre><code>def __init__(config, phantom_name)\n</code></pre> <p>Initializes the analysis strategy.</p> <p>Arguments:</p> <ul> <li><code>config</code> Config - The main configuration object.</li> <li><code>phantom_name</code> str - The name of the phantom being analyzed.</li> </ul> <p></p>"},{"location":"api_reference/#get_results_base_dir_3","title":"get_results_base_dir","text":"<pre><code>@abstractmethod\ndef get_results_base_dir()\n</code></pre> <p>Returns the base directory where results for this strategy are stored.</p> <p></p>"},{"location":"api_reference/#get_plots_dir_3","title":"get_plots_dir","text":"<pre><code>@abstractmethod\ndef get_plots_dir()\n</code></pre> <p>Returns the directory where plots for this strategy should be saved.</p> <p></p>"},{"location":"api_reference/#load_and_process_results_2","title":"load_and_process_results","text":"<pre><code>@abstractmethod\ndef load_and_process_results(analyzer)\n</code></pre> <p>Loads and processes all relevant simulation results for the analysis.</p> <p>Arguments:</p> <ul> <li><code>analyzer</code> Analyzer - The main analyzer instance calling the strategy.</li> </ul> <p></p>"},{"location":"api_reference/#get_normalization_factor_3","title":"get_normalization_factor","text":"<pre><code>@abstractmethod\ndef get_normalization_factor(frequency_mhz, simulated_power_w)\n</code></pre> <p>Calculates the normalization factor to apply to SAR values.</p> <p>Arguments:</p> <ul> <li><code>frequency_mhz</code> int - The simulation frequency in MHz.</li> <li><code>simulated_power_w</code> float - The input power from the simulation in Watts.</li> </ul> <p>Returns:</p> <ul> <li><code>float</code> - The calculated normalization factor.</li> </ul> <p></p>"},{"location":"api_reference/#extract_data_2","title":"extract_data","text":"<pre><code>@abstractmethod\ndef extract_data(pickle_data, frequency_mhz, detailed_name, scenario_name,\n                 sim_power, norm_factor)\n</code></pre> <p>Extracts and structures data from a single simulation's result files.</p> <p>Arguments:</p> <ul> <li><code>pickle_data</code> dict - Data loaded from the .pkl result file.</li> <li><code>frequency_mhz</code> int - The simulation frequency.</li> <li><code>detailed_name</code> str - The detailed name of the placement or scenario.</li> <li><code>scenario_name</code> str - The general scenario name.</li> <li><code>sim_power</code> float - The simulated input power in Watts.</li> <li><code>norm_factor</code> float - The normalization factor to apply.</li> </ul> <p>Returns:</p> <ul> <li><code>tuple</code> - A tuple containing the main result entry (dict) and a list of organ-specific entries (list of dicts).</li> </ul> <p></p>"},{"location":"api_reference/#apply_bug_fixes_3","title":"apply_bug_fixes","text":"<pre><code>@abstractmethod\ndef apply_bug_fixes(result_entry)\n</code></pre> <p>Applies any necessary workarounds or fixes for known data inconsistencies.</p> <p>Arguments:</p> <ul> <li><code>result_entry</code> dict - The data entry for a single simulation result.</li> </ul> <p>Returns:</p> <ul> <li><code>dict</code> - The corrected result entry.</li> </ul> <p></p>"},{"location":"api_reference/#calculate_summary_stats_3","title":"calculate_summary_stats","text":"<pre><code>@abstractmethod\ndef calculate_summary_stats(results_df)\n</code></pre> <p>Calculates summary statistics from the aggregated results DataFrame.</p> <p>Arguments:</p> <ul> <li><code>results_df</code> pd.DataFrame - The DataFrame containing all aggregated simulation results.</li> </ul> <p>Returns:</p> <ul> <li><code>pd.DataFrame</code> - A DataFrame with summary statistics.</li> </ul> <p></p>"},{"location":"api_reference/#generate_plots_2","title":"generate_plots","text":"<pre><code>@abstractmethod\ndef generate_plots(analyzer, plotter, results_df, all_organ_results_df)\n</code></pre> <p>Generates all plots relevant to this analysis strategy.</p> <p>Arguments:</p> <ul> <li><code>analyzer</code> Analyzer - The main analyzer instance.</li> <li><code>plotter</code> Plotter - The plotter instance to use for generating plots.</li> <li><code>results_df</code> pd.DataFrame - The DataFrame with main aggregated results.</li> <li><code>all_organ_results_df</code> pd.DataFrame - The DataFrame with detailed organ-level results.</li> </ul> <p></p>"},{"location":"api_reference/#nearfieldanalysisstrategy_1","title":"NearFieldAnalysisStrategy","text":"<pre><code>class NearFieldAnalysisStrategy(BaseAnalysisStrategy)\n</code></pre> <p>Analysis strategy for near-field simulations.</p> <p></p>"},{"location":"api_reference/#get_results_base_dir_4","title":"get_results_base_dir","text":"<pre><code>def get_results_base_dir()\n</code></pre> <p>Returns the base directory for near-field results.</p> <p></p>"},{"location":"api_reference/#get_plots_dir_4","title":"get_plots_dir","text":"<pre><code>def get_plots_dir()\n</code></pre> <p>Returns the directory for saving near-field plots.</p> <p></p>"},{"location":"api_reference/#load_and_process_results_3","title":"load_and_process_results","text":"<pre><code>def load_and_process_results(analyzer)\n</code></pre> <p>Iterates through near-field simulation results and processes each one.</p> <p></p>"},{"location":"api_reference/#get_normalization_factor_4","title":"get_normalization_factor","text":"<pre><code>def get_normalization_factor(frequency_mhz, simulated_power_w)\n</code></pre> <p>Calculates the normalization factor based on the target power defined in the antenna configuration.</p> <p>Arguments:</p> <ul> <li><code>frequency_mhz</code> int - The simulation frequency in MHz.</li> <li><code>simulated_power_w</code> float - The input power from the simulation in Watts.</li> </ul> <p>Returns:</p> <ul> <li><code>float</code> - The calculated normalization factor. Returns 1.0 if normalization is not possible.</li> </ul> <p></p>"},{"location":"api_reference/#extract_data_3","title":"extract_data","text":"<pre><code>def extract_data(pickle_data, frequency_mhz, placement_name, scenario_name,\n                 sim_power, norm_factor)\n</code></pre> <p>Extracts and normalizes SAR data from a single near-field simulation result.</p> <p>Arguments:</p> <ul> <li><code>pickle_data</code> dict - Data loaded from the .pkl result file.</li> <li><code>frequency_mhz</code> int - The simulation frequency.</li> <li><code>placement_name</code> str - The detailed name of the placement.</li> <li><code>scenario_name</code> str - The general scenario name (e.g., 'by_cheek').</li> <li><code>sim_power</code> float - The simulated input power in Watts.</li> <li><code>norm_factor</code> float - The normalization factor to apply to SAR values.</li> </ul> <p>Returns:</p> <ul> <li><code>tuple</code> - A tuple containing the main result entry (dict) and a list of organ-specific entries.</li> </ul> <p></p>"},{"location":"api_reference/#apply_bug_fixes_4","title":"apply_bug_fixes","text":"<pre><code>def apply_bug_fixes(result_entry)\n</code></pre> <p>Applies a workaround for a known issue where Head SAR is miscategorized as Trunk SAR.</p> <p>Arguments:</p> <ul> <li><code>result_entry</code> dict - The data entry for a single simulation result.</li> </ul> <p>Returns:</p> <ul> <li><code>dict</code> - The corrected result entry.</li> </ul> <p></p>"},{"location":"api_reference/#calculate_summary_stats_4","title":"calculate_summary_stats","text":"<pre><code>def calculate_summary_stats(results_df)\n</code></pre> <p>Calculates summary statistics, including completion progress for each scenario.</p> <p>Arguments:</p> <ul> <li><code>results_df</code> pd.DataFrame - The DataFrame containing all aggregated simulation results.</li> </ul> <p>Returns:</p> <ul> <li><code>pd.DataFrame</code> - A DataFrame with mean SAR values and a 'progress' column.</li> </ul> <p></p>"},{"location":"api_reference/#generate_plots_3","title":"generate_plots","text":"<pre><code>def generate_plots(analyzer, plotter, results_df, all_organ_results_df)\n</code></pre> <p>Generates all plots for the near-field analysis.</p> <p>This includes bar charts for average SAR, line plots for psSAR, and boxplots for SAR distribution.</p> <p>Arguments:</p> <ul> <li><code>analyzer</code> Analyzer - The main analyzer instance.</li> <li><code>plotter</code> Plotter - The plotter instance to use for generating plots.</li> <li><code>results_df</code> pd.DataFrame - The DataFrame with main aggregated results.</li> <li><code>all_organ_results_df</code> pd.DataFrame - The DataFrame with detailed organ-level results.</li> </ul> <p></p>"},{"location":"api_reference/#farfieldanalysisstrategy_1","title":"FarFieldAnalysisStrategy","text":"<pre><code>class FarFieldAnalysisStrategy(BaseAnalysisStrategy)\n</code></pre> <p>Analysis strategy for far-field simulations.</p> <p></p>"},{"location":"api_reference/#module-srcantenna","title":"Module src.antenna","text":""},{"location":"api_reference/#antenna_1","title":"Antenna","text":"<pre><code>class Antenna()\n</code></pre> <p>Manages antenna-specific properties and configurations.</p> <p></p>"},{"location":"api_reference/#__init___13","title":"__init__","text":"<pre><code>def __init__(config: \"Config\", frequency_mhz: int)\n</code></pre> <p>Initializes the Antenna object.</p> <p>Arguments:</p> <ul> <li><code>config</code> - The configuration object containing antenna settings.</li> <li><code>frequency_mhz</code> - The operating frequency in MHz.</li> </ul> <p></p>"},{"location":"api_reference/#get_config_for_frequency_1","title":"get_config_for_frequency","text":"<pre><code>def get_config_for_frequency() -&gt; dict\n</code></pre> <p>Gets the antenna configuration for the current frequency.</p> <p>Raises:</p> <ul> <li><code>ValueError</code> - If no configuration is defined for the frequency.</li> </ul> <p>Returns:</p> <p>The antenna configuration dictionary.</p> <p></p>"},{"location":"api_reference/#get_model_type_1","title":"get_model_type","text":"<pre><code>def get_model_type() -&gt; str\n</code></pre> <p>Gets the antenna model type (e.g., 'PIFA', 'IFA').</p> <p></p>"},{"location":"api_reference/#get_source_entity_name_1","title":"get_source_entity_name","text":"<pre><code>def get_source_entity_name() -&gt; str\n</code></pre> <p>Gets the name of the source entity in the CAD model.</p> <p></p>"},{"location":"api_reference/#get_centered_antenna_path_1","title":"get_centered_antenna_path","text":"<pre><code>def get_centered_antenna_path(centered_antennas_dir: str) -&gt; str\n</code></pre> <p>Constructs the path to the centered .sab antenna file.</p> <p>Arguments:</p> <ul> <li><code>centered_antennas_dir</code> - The directory for centered antenna files.</li> </ul> <p>Returns:</p> <p>The absolute path to the centered antenna model file.</p> <p></p>"},{"location":"api_reference/#module-srccolors","title":"Module src.colors","text":""},{"location":"api_reference/#get_color_1","title":"get_color","text":"<pre><code>def get_color(log_type: str) -&gt; str\n</code></pre> <p>Retrieves the colorama color code for a given log type.</p> <p>Arguments:</p> <ul> <li><code>log_type</code> - The type of log message (e.g., 'info', 'warning').</li> </ul> <p>Returns:</p> <p>The colorama color code for the log type.</p> <p></p>"},{"location":"api_reference/#module-srcconfig","title":"Module src.config","text":""},{"location":"api_reference/#deep_merge_1","title":"deep_merge","text":"<pre><code>def deep_merge(source: dict, destination: dict) -&gt; dict\n</code></pre> <p>Recursively merges two dictionaries, overwriting destination with source values.</p> <p>Arguments:</p> <ul> <li><code>source</code> - The dictionary with values to merge.</li> <li><code>destination</code> - The dictionary to be merged into.</li> </ul> <p>Returns:</p> <p>The merged dictionary.</p> <p></p>"},{"location":"api_reference/#config_1","title":"Config","text":"<pre><code>class Config()\n</code></pre> <p>Manages loading and access of hierarchical JSON configurations.</p> <p></p>"},{"location":"api_reference/#__init___14","title":"__init__","text":"<pre><code>def __init__(base_dir: str, config_filename: str = \"near_field_config.json\")\n</code></pre> <p>Initializes the Config object by loading all relevant configuration files.</p> <p>Arguments:</p> <ul> <li><code>base_dir</code> - The base directory of the project.</li> <li><code>config_filename</code> - The name of the main configuration file to load.</li> </ul> <p></p>"},{"location":"api_reference/#get_setting_1","title":"get_setting","text":"<pre><code>def get_setting(path: str, default=None)\n</code></pre> <p>Retrieves a nested setting using a dot-separated path.</p> <p>Example:</p> <p><code>get_setting(\"simulation_parameters.number_of_point_sensors\")</code></p> <p>Arguments:</p> <ul> <li><code>path</code> - The dot-separated path to the setting.</li> <li><code>default</code> - The default value to return if the setting is not found.</li> </ul> <p>Returns:</p> <p>The value of the setting, or the default value.</p> <p></p>"},{"location":"api_reference/#get_simulation_parameters_1","title":"get_simulation_parameters","text":"<pre><code>def get_simulation_parameters() -&gt; dict\n</code></pre> <p>Gets the 'simulation_parameters' dictionary.</p> <p>&lt;a id=\"src.config.Config.get</p>"},{"location":"configuration/","title":"GOLIAT Configuration Guide","text":"<p>GOLIAT uses a hierarchical JSON configuration system to define all aspects of a simulation study. This modular approach allows for flexibility and reproducibility. A study-specific configuration file (e.g., <code>near_field_config.json</code>) inherits settings from a <code>base_config.json</code> file, allowing you to override only the parameters you need for a specific study.</p> <p>This guide provides a comprehensive reference for all available configuration parameters, their purpose, and valid values.</p>"},{"location":"configuration/#configuration-hierarchy","title":"Configuration Hierarchy","text":"<p>The system is designed to avoid repetition by allowing configurations to \"extend\" a base file. The child's values will always override the parent's.</p> <pre><code>graph TD\n    base[base_config.json&lt;br/&gt;Shared settings]\n    nf[near_field_config.json&lt;br/&gt;Near-field specifics]\n    ff[far_field_config.json&lt;br/&gt;Far-field specifics]\n\n    base --&gt;|extends| nf\n    base --&gt;|extends| ff\n\n    style base fill:#4CAF50\n    style nf fill:#2196F3\n    style ff fill:#2196F3</code></pre> <p>To create a custom study, you can copy an existing configuration and modify it. For example, to create <code>my_study.json</code>:</p> <pre><code>{\n  \"extends\": \"near_field_config.json\",\n  \"phantoms\": [\"thelonious\"],\n  \"frequencies_mhz\": [900]\n}\n</code></pre>"},{"location":"configuration/#1-core-settings-base_configjson","title":"1. Core Settings (<code>base_config.json</code>)","text":"<p>These are the foundational settings shared across all study types.</p> Parameter Type Example Value Description <code>extends</code> string <code>\"base_config.json\"</code> (Optional) Specifies the parent configuration file to inherit from. This is typically used in study-specific configs. <code>study_type</code> string <code>\"near_field\"</code> (Required) The type of study to run. Valid options are <code>\"near_field\"</code> or <code>\"far_field\"</code>. <code>use_gui</code> boolean <code>true</code> If <code>true</code>, the graphical user interface (GUI) will be launched to monitor progress. If <code>false</code>, the study runs in headless mode, printing logs to the console. <code>phantoms</code> array <code>[\"thelonious\", \"eartha\"]</code> A list of the virtual human phantom models to be used in the study. For near-field studies, you can also include <code>\"freespace\"</code> to run a simulation of the antenna in isolation. <code>verbose</code> boolean <code>false</code> If <code>true</code>, enables detailed verbose logging to the console, in addition to the standard progress logs. <p></p>"},{"location":"configuration/#2-execution-control-execution_control","title":"2. Execution Control (<code>execution_control</code>)","text":"<p>This object controls which phases of the workflow are executed. This is useful for re-running specific parts of a study, such as only extracting results from an already completed simulation.</p> Parameter Type Default Description <code>do_setup</code> boolean <code>true</code> If <code>true</code>, the simulation scene will be built (phantoms loaded, materials assigned, etc.). <code>do_run</code> boolean <code>true</code> If <code>true</code>, the simulation solver will be executed. <code>do_extract</code> boolean <code>true</code> If <code>true</code>, the results will be extracted from the simulation output and processed. <code>only_write_input_file</code> boolean <code>false</code> If <code>true</code>, the <code>run</code> phase will only generate the solver input file (<code>.h5</code>) and then stop, without actually running the simulation. This is useful for debugging the setup or for preparing files for a manual cloud submission. <code>batch_run</code> boolean <code>false</code> If <code>true</code>, enables the oSPARC batch submission workflow. This is an advanced feature for running many simulations in parallel on the cloud. <code>auto_cleanup_previous_results</code> array <code>[]</code> A list of file types to automatically delete after a simulation's results have been successfully extracted. This helps to preserve disk space in serial workflows. Valid values are: <code>\"output\"</code> (<code>*_Output.h5</code>), <code>\"input\"</code> (<code>*_Input.h5</code>), and <code>\"smash\"</code> (<code>*.smash</code>). Warning: This feature is incompatible with parallel or batch runs and should only be used when <code>do_setup</code>, <code>do_run</code>, and <code>do_extract</code> are all <code>true</code>. <p>The <code>do_setup</code> flag directly controls the project file (<code>.smash</code>) handling. Its behavior is summarized below:</p> <code>do_setup</code> Value File Exists? Action <code>true</code> Yes Delete and Override with a new project. <code>true</code> No Create a new project. <code>false</code> Yes Open and Use the existing project. <code>false</code> No Error and terminate the program. <p>Example: Extraction-Only Workflow <pre><code>\"execution_control\": {\n  \"do_setup\": false,\n  \"do_run\": false,\n  \"do_extract\": true\n}\n</code></pre></p> <p>Example: Aggressive Cleanup in a Serial Workflow <pre><code>\"execution_control\": {\n  \"do_setup\": true,\n  \"do_run\": true,\n  \"do_extract\": true,\n  \"auto_cleanup_previous_results\": [\"output\", \"input\"]\n}\n</code></pre></p> <p></p>"},{"location":"configuration/#3-simulation-parameters-simulation_parameters","title":"3. Simulation Parameters (<code>simulation_parameters</code>)","text":"<p>These settings control the core behavior of the FDTD solver.</p> Parameter Type Example Value Description <code>global_auto_termination</code> string <code>\"GlobalAutoTerminationUserDefined\"</code> The solver's termination criteria. <code>\"GlobalAutoTerminationWeak\"</code> is a common default, while <code>\"GlobalAutoTerminationUserDefined\"</code> allows for a custom convergence level. <code>convergence_level_dB</code> number <code>-15</code> The convergence threshold in decibels (dB) when using user-defined termination. The simulation stops when the energy in the system decays below this level. <code>simulation_time_multiplier</code> number <code>3.5</code> A multiplier used to determine the total simulation time. The time is calculated as the duration it takes for a wave to traverse the simulation bounding box diagonal, multiplied by this value. <code>number_of_point_sensors</code> number <code>8</code> The number of point sensors to place at the corners of the simulation bounding box. These sensors monitor the electric field over time. <code>point_source_order</code> array <code>[\"lower_left_bottom\", ...]</code> Defines the specific order and location of the point sensors at the 8 corners of the bounding box. <code>excitation_type</code> string <code>\"Harmonic\"</code> The type of excitation source. <code>\"Harmonic\"</code> is used for single-frequency simulations (standard for SAR). <code>\"Gaussian\"</code> is used for a frequency sweep, typically for antenna characterization in free-space. <code>bandwidth_mhz</code> number <code>50.0</code> The bandwidth in MHz for a Gaussian excitation. <code>bbox_padding_mm</code> number <code>50</code> (Far-Field) Padding in millimeters to add around the phantom's bounding box to define the simulation domain. <code>freespace_antenna_bbox_expansion_mm</code> array <code>[20, 20, 20]</code> (Near-Field) Padding in [x, y, z] millimeters to add around the antenna for free-space simulations. <p></p>"},{"location":"configuration/#4-gridding-parameters-gridding_parameters","title":"4. Gridding Parameters (<code>gridding_parameters</code>)","text":"<p>These settings define the spatial discretization of the simulation domain.</p> Parameter Type Example Value Description <code>global_gridding.grid_mode</code> string <code>\"automatic\"</code> The global gridding strategy. Can be <code>\"automatic\"</code> or <code>\"manual\"</code>. <code>global_gridding.refinement</code> string <code>\"AutoRefinementDefault\"</code> For automatic gridding, this sets the refinement level. Options: <code>\"VeryFine\"</code>, <code>\"Fine\"</code>, <code>\"Default\"</code>, <code>\"Coarse\"</code>, <code>\"VeryCoarse\"</code>. <code>global_gridding.manual_fallback_max_step_mm</code> number <code>5.0</code> For manual gridding, this is the maximum grid step size in millimeters used as a fallback. <code>global_gridding_per_frequency</code> object <code>{\"700\": 3.0}</code> (Far-Field) A mapping of frequency (in MHz) to a specific manual grid step size in millimeters. This allows for finer grids at higher frequencies. <code>padding.padding_mode</code> string <code>\"automatic\"</code> Defines how padding is applied around the simulation domain. Can be <code>\"automatic\"</code> or <code>\"manual\"</code>. <code>padding.manual_bottom_padding_mm</code> array <code>[0, 0, 0]</code> For manual padding, the [x, y, z] padding in millimeters at the bottom of the domain. <code>padding.manual_top_padding_mm</code> array <code>[0, 0, 0]</code> For manual padding, the [x, y, z] padding in millimeters at the top of the domain. <p></p>"},{"location":"configuration/#5-solver-and-miscellaneous-settings","title":"5. Solver and Miscellaneous Settings","text":"Parameter Type Example Value Description <code>solver_settings.kernel</code> string <code>\"Acceleware\"</code> The solver kernel to use. <code>\"Software\"</code> (CPU), <code>\"Acceleware\"</code> (GPU, required for near-field due to SIBC support), or <code>\"CUDA\"</code> (GPU). <code>solver_settings.boundary_conditions.type</code> string <code>\"UpmlCpml\"</code> The type of Perfectly Matched Layer (PML) boundary conditions. <code>solver_settings.boundary_conditions.strength</code> string <code>\"Medium\"</code> The strength of the PML boundary conditions. Options: <code>\"Weak\"</code>, <code>\"Medium\"</code>, <code>\"Strong\"</code>. <code>manual_isolve</code> boolean <code>true</code> If <code>true</code>, runs the <code>iSolve.exe</code> solver directly. This is the recommended setting to avoid a known bug with the Ares scheduler. <code>export_material_properties</code> boolean <code>false</code> (Advanced) If <code>true</code>, the framework will extract and save material properties from the simulation to a <code>.pkl</code> file. <code>line_profiling</code> object See below (Advanced) Enables detailed line-by-line code profiling for specific functions to debug performance. <p>Example: Line Profiling <pre><code>\"line_profiling\": {\n  \"enabled\": true,\n  \"subtasks\": {\n    \"setup_simulation\": [\"src.setups.base_setup.BaseSetup._finalize_setup\"]\n  }\n}\n</code></pre></p>"},{"location":"configuration/#6-far-field-specifics-far_field_configjson","title":"6. Far-Field Specifics (<code>far_field_config.json</code>)","text":"<p>These settings are unique to far-field (environmental exposure) studies.</p> Parameter Type Example Value Description <code>frequencies_mhz</code> array <code>[450, 700, 900]</code> An array of frequencies in MHz to simulate. Each frequency will generate a separate <code>.smash</code> project file containing simulations for all directions and polarizations. <code>far_field_setup.type</code> string <code>\"environmental\"</code> The far-field scenario type. Currently, only <code>\"environmental\"</code> (plane waves) is fully implemented. <code>far_field_setup.environmental.incident_directions</code> array <code>[\"x_pos\", \"y_neg\"]</code> A list of plane wave incident directions. Supported values are single-axis directions: <code>\"x_pos\"</code>, <code>\"x_neg\"</code>, <code>\"y_pos\"</code>, <code>\"y_neg\"</code>, <code>\"z_pos\"</code>, <code>\"z_neg\"</code>. <code>far_field_setup.environmental.polarizations</code> array <code>[\"theta\", \"phi\"]</code> A list of polarizations to simulate for each incident direction. <code>\"theta\"</code> corresponds to vertical polarization and <code>\"phi\"</code> to horizontal. <p></p>"},{"location":"configuration/#7-near-field-specifics-near_field_configjson","title":"7. Near-Field Specifics (<code>near_field_config.json</code>)","text":"<p>These settings are unique to near-field (device exposure) studies.</p>"},{"location":"configuration/#antenna-configuration-antenna_config","title":"Antenna Configuration (<code>antenna_config</code>)","text":"<p>This object defines all antenna-specific information, with a separate entry for each frequency.</p> Parameter Type Example Value Description <code>antenna_config.{freq}.model_type</code> string <code>\"PIFA\"</code> The type of antenna model, used to select specific setup logic. Options: <code>\"PIFA\"</code>, <code>\"IFA\"</code>. <code>antenna_config.{freq}.source_name</code> string <code>\"Lines 1\"</code> The name of the source entity within the antenna's CAD model. <code>antenna_config.{freq}.materials</code> object <code>{ \"Extrude 1\": \"Copper\", ...}</code> Maps component names in the antenna's CAD model to Sim4Life material names. <code>antenna_config.{freq}.gridding</code> object <code>{ \"automatic\": [...], \"manual\": {...} }</code> Defines gridding strategies (automatic or manual with specific step sizes) for different parts of the antenna model. <code>antenna_config.{freq}.gridding.subgridding</code> object <code>{ \"components\": [...], ...}</code> (Optional) Enables subgridding for a list of components, which overrides any manual gridding settings for those components. This is useful for finely detailed parts that require a much higher resolution than the rest of the model."},{"location":"configuration/#placement-scenarios-placement_scenarios","title":"Placement Scenarios (<code>placement_scenarios</code>)","text":"<p>This object defines the different device placements to be simulated.</p> Parameter Type Example Value Description <code>placement_scenarios.{name}.positions</code> object <code>{ \"center\": [0,0,0], ...}</code> A set of named relative positions (as [x, y, z] offsets) for the placement scenario. <code>placement_scenarios.{name}.orientations</code> object <code>{ \"vertical\": [], ...}</code> A set of named orientations to be applied at each position. Each orientation is a list of rotation steps. <code>placement_scenarios.{name}.bounding_box</code> string <code>\"default\"</code> Determines which part of the phantom to include in the simulation bounding box. Options: <code>\"default\"</code>, <code>\"head\"</code>, <code>\"trunk\"</code>, <code>\"whole_body\"</code>. The <code>\"default\"</code> option intelligently chooses \"head\" for eye/cheek placements and \"trunk\" for belly placements."},{"location":"configuration/#phantom-definitions-phantom_definitions","title":"Phantom Definitions (<code>phantom_definitions</code>)","text":"<p>This object contains phantom-specific settings, such as which placements to run and the separation distances.</p> Parameter Type Example Value Description <code>phantom_definitions.{name}.placements</code> object <code>{ \"do_by_cheek\": true, ...}</code> A set of booleans to enable or disable specific placement scenarios for a given phantom. The key must match a scenario name from <code>placement_scenarios</code>. <code>phantom_definitions.{name}.distance_from_cheek</code> number <code>8</code> The separation distance in millimeters for the \"by_cheek\" placement. <code>phantom_definitions.{name}.distance_from_eye</code> number <code>200</code> The separation distance in millimeters for the \"front_of_eyes\" placement. <code>phantom_definitions.{name}.distance_from_belly</code> number <code>100</code> The separation distance in millimeters for the \"by_belly\" placement. <code>phantom_definitions.{name}.lips</code> array <code>[0, 122, 31]</code> The [x, y, z] coordinates of the center of the lips, used for the 'cheek' placement calculation."},{"location":"configuration/#8-credentials-and-data","title":"8. Credentials and Data","text":"<p>For security and portability, certain information is handled outside the main configuration files.</p>"},{"location":"configuration/#osparc-credentials","title":"oSPARC Credentials","text":"<p>oSPARC API credentials should be stored in a <code>.env</code> file in the project root directory.</p> <pre><code># .env file\nOSPARC_API_KEY=your_osparc_api_key\nOSPARC_API_SECRET=your_osparc_api_secret\n</code></pre>"},{"location":"configuration/#phantom-downloads","title":"Phantom Downloads","text":"<p>Some phantom models require an email address for download, which can also be set in the <code>.env</code> file. This should be the email associated with your institution's Sim4Life license.</p> <pre><code># .env file\nDOWNLOAD_EMAIL=your_email@example.com\n</code></pre> <p>This comprehensive structure ensures that every aspect of a GOLIAT simulation is controllable, reproducible, and easy to manage. For more workflow-oriented information, please see the User Guide.</p>"},{"location":"developer_guide/","title":"Developer Guide","text":"<p>This guide is for developers extending or maintaining GOLIAT. It covers the codebase structure, testing, and contribution process. GOLIAT is modular Python code interfacing with Sim4Life for EMF simulations.</p>"},{"location":"developer_guide/#codebase-structure","title":"Codebase structure","text":"<p>GOLIAT's architecture separates concerns:</p> <ul> <li>src/config.py: Loads JSON configs with inheritance (e.g., base + study-specific).</li> <li>src/studies/: Orchestrates workflows (NearFieldStudy, FarFieldStudy inherit from BaseStudy).</li> <li>src/setups/: Builds Sim4Life scenes (PhantomSetup, PlacementSetup, MaterialSetup, etc.).</li> <li>src/project_manager.py: Handles .smash files (create/open/save/close), including a \"Verify and Resume\" feature to avoid re-running simulations with unchanged configurations.</li> <li>src/simulation_runner.py: Executes simulations (local iSolve or oSPARC cloud).</li> <li>src/results_extractor.py: Extracts SAR/power data post-simulation.</li> <li>src/analysis/: Aggregates results (Analyzer with strategies for near/far-field).</li> <li>src/gui_manager.py: Multiprocessing GUI for progress/ETA.</li> <li>src/logging_manager.py: Dual loggers (progress/verbose) with colors.</li> <li>src/profiler.py: Tracks phases (setup/run/extract) for ETAs.</li> <li>src/utils.py: Helpers (format_time, non_blocking_sleep, simple Profiler).</li> </ul> <p>Key flow: Config \u2192 BaseStudy.run() \u2192 Setups \u2192 Runner \u2192 Extractor \u2192 Analyzer. For more details on the high-level architecture, see the Technical Guide.</p>"},{"location":"developer_guide/#testing","title":"Testing","text":"<p>GOLIAT uses <code>pytest</code> for testing, with tests located in the <code>tests/</code> directory.</p>"},{"location":"developer_guide/#handling-the-s4l_v1-dependency","title":"Handling the <code>s4l_v1</code> dependency","text":"<p>Much of the codebase requires <code>s4l_v1</code>, a proprietary library available only within the Sim4Life Python environment on Windows. This prevents tests that rely on it from running in the Linux-based CI environment.</p> <p>To manage this, tests requiring <code>s4l_v1</code> are marked with <code>@pytest.mark.skip_on_ci</code>. The CI pipeline is configured to exclude these marked tests, allowing it to validate platform-independent code while avoiding environment-specific failures.</p> <pre><code># Command used in .github/workflows/test.yml\npytest -m \"not skip_on_ci\" tests/\n</code></pre>"},{"location":"developer_guide/#local-testing-setup","title":"Local testing setup","text":"<p>To run the complete test suite, your local development environment must use the Sim4Life Python interpreter.</p>"},{"location":"developer_guide/#vs-code-configuration","title":"VS Code Configuration","text":"<ol> <li>Open the Command Palette (<code>Ctrl+Shift+P</code>).</li> <li>Run the <code>Python: Select Interpreter</code> command.</li> <li>Select <code>+ Enter interpreter path...</code> and find the <code>python.exe</code> in your Sim4Life installation directory (e.g., <code>C:\\Program Files\\Sim4Life_8.2.0.16876\\Python\\python.exe</code>). This configures VS Code to use the correct interpreter, which includes the <code>s4l_v1</code> library.</li> </ol>"},{"location":"developer_guide/#running-tests-locally","title":"Running tests locally","text":"<p>With the interpreter set, run the full test suite from the terminal.</p> <ol> <li>Install Dependencies:     <pre><code>pip install -r requirements.txt\n</code></pre></li> <li>Run Pytest:     <pre><code># This executes all tests, including those skipped by CI\npytest tests/ -v\n</code></pre></li> </ol>"},{"location":"developer_guide/#adding-new-tests","title":"Adding new tests","text":"<ul> <li>If a new test depends on <code>s4l_v1</code> (or imports a module that does), it must be decorated with <code>@pytest.mark.skip_on_ci</code>.</li> <li>If a test is self-contained and has no Sim4Life dependencies, it does not need the marker.</li> </ul> <pre><code>import pytest\nfrom src.utils import format_time # This module has s4l_v1 dependencies\n\n# This test requires the Sim4Life environment and will be skipped on CI.\n@pytest.mark.skip_on_ci\ndef test_a_function_that_needs_s4l():\n    # ... test logic ...\n    pass\n\n# This test is self-contained and will run everywhere.\ndef test_a_self_contained_function():\n    assert 2 + 2 == 4\n</code></pre>"},{"location":"developer_guide/#extending-the-framework","title":"Extending the framework","text":""},{"location":"developer_guide/#adding-a-new-setup","title":"Adding a new setup","text":"<p>To add a custom source (e.g., dipole):</p> <ol> <li>Create <code>src/setups/dipole_setup.py</code> inheriting BaseSetup.</li> <li>Implement <code>run_full_setup()</code>: Load dipole CAD, position.</li> <li>Update NearFieldStudy/FarFieldStudy to use it (e.g., if \"study_type\": \"dipole\").</li> <li>Add to config schema in config.py.</li> </ol> <p>Example in dipole_setup.py:</p> <pre><code>class DipoleSetup(BaseSetup):\n    def run_full_setup(self, project_manager):\n        # Custom logic\n        pass\n</code></pre>"},{"location":"developer_guide/#contribution-workflow","title":"Contribution workflow","text":"<ol> <li>Fork the repo.</li> <li>Create branch: <code>git checkout -b feature/new-setup</code>.</li> <li>Code: Follow style (Ruff-formatted, type hints).</li> <li>Test locally: <code>pytest</code>.</li> <li>Commit: <code>git commit -m \"Add dipole setup\"</code>.</li> <li>PR to main: Describe changes, reference issues.</li> </ol> <p>PR requirements: - Run pre-commit: <code>pre-commit run --all-files</code>. - Tests: Add for new features. - Docs: Update user_guide.md if user-facing.</p>"},{"location":"developer_guide/#building-docs","title":"Building docs","text":"<p>To build the documentation, you first need to install the documentation-specific dependencies.</p> <pre><code># Install docs dependencies\npip install -r requirements-docs.txt\n</code></pre> <p>Then, you can use MkDocs to serve the documentation locally or build the static site.</p> <pre><code># Serve the docs locally\nmkdocs serve  # Local server at http://127.0.0.1:8000\n\n# Build the static site\nmkdocs build  # Outputs to site/\n</code></pre> <p>For UML (docs/classes.puml): Use PlantUML viewer or VS Code extension.</p>"},{"location":"developer_guide/#code-style","title":"Code style","text":"<ul> <li>Formatting &amp; Linting: Ruff (replaces Black, flake8, isort).</li> <li>Type Checking: Pyright.</li> <li>Types: Use typing (e.g., <code>Dict[str, Any]</code>).</li> <li>Docs: Google-style docstrings.</li> </ul> <p>Pre-commit hook (install: <code>pre-commit install</code>):</p> <pre><code># .pre-commit-config.yaml\nrepos:\n  - repo: https://github.com/astral-sh/ruff-pre-commit\n    rev: v0.14.2 # Or newer\n    hooks:\n      - id: ruff-format\n      - id: ruff\n        args: [--fix]\n  - repo: https://github.com/RobertCraigie/pyright-python\n    rev: v1.1.407 # Or newer\n    hooks:\n      - id: pyright\n</code></pre> <p>Run: <code>pre-commit run</code>.</p>"},{"location":"developer_guide/#other-notes","title":"Other notes","text":"<ul> <li>Dependencies: requirements.txt (no Poetry).</li> <li>Gitignore: Ignore logs/, results/, .env.</li> <li>License: MIT \u2013 see LICENSE.</li> <li>Changelog: Update CHANGELOG.md for releases.</li> </ul> <p>For more, see Contributing. For a deep dive into all available parameters, refer to the Configuration Guide.</p>"},{"location":"project_info/","title":"Project Information","text":""},{"location":"project_info/#about-projectgoliat","title":"About #ProjectGOLIAT","text":"<p>GOLIAT (5G expOsure, causaL effects, and rIsk perception through citizen engAgemenT) is a research project that aims to characterize and monitor RF-EMF exposure, in particular 5G, provide novel insights into potential causal neuropsychological and biological effects, and understand risk perception and communication through citizen engagement using an integrative and transdisciplinary pan-European approach.</p> <p>The primary objectives of the project include:</p> <ul> <li>Automated Dosimetry: Creating a Python-based framework to automate simulations using the Sim4Life platform.</li> <li>Child Phantom Analysis: Performing simulations on detailed child phantoms, such as \"Thelonious\" and \"Eartha,\" to understand age-dependent effects.</li> <li>Comprehensive SAR Analysis: Calculating Specific Absorption Rate (SAR) metrics, including whole-body, head, trunk, and peak spatial-average SAR (psSAR10g) in sensitive tissues like the skin, eyes, and brain.</li> <li>Varied Exposure Scenarios: Investigating numerous exposure conditions, including different frequencies, antenna types, and device positions (e.g., by the cheek, in front of the eyes, near the belly).</li> </ul> <p>Check out the GOLIAT website!</p>"},{"location":"project_info/#funding-and-acknowledgements","title":"Funding and acknowledgements","text":"<p>This work is part of the GOLIAT project, which has received funding from the European Union's Horizon Health program under the call HORIZON-HEALTH-2021-ENVHLTH-02-01 \u2013 Exposure to electromagnetic fields (EMF) and health. GOLIAT is part of the CLUE-H consortium with ETAIN, NextGEM and SEAWave.</p> <p>Check out the CLUE-H website!</p>"},{"location":"project_info/#project-partners","title":"Project partners","text":"<p>The GOLIAT consortium consists of 22 partners from across Europe and the United States:</p> <ul> <li>Barcelona Institute for Global Health (ISGlobal), ES (Coordinator)</li> <li>Ghent University (UGent) and IMEC, BE (lead subtask 1.5)</li> <li>Telecom Paris (TP), FR</li> <li>Consiglio Nazionale delle Ricerche (CNR), IT</li> <li>Swiss Tropical and Public Health Institute (SwissTPH), CH</li> <li>Nofer Institute of Occupational Medicine (NIOM), PL</li> <li>University of Bristol (UNIVBRIS), UK</li> <li>Universit\u00e0 degli Studi di Torino (UNITO), IT</li> <li>Academisch Medisch Centrum (AMC), NL</li> <li>Centre National de la Recherche Scientifique (CNRS), FR</li> <li>National Institute of Industrial Environment and Risks (INERIS), FR</li> <li>University La Sapienza (UNIROMA1), IT</li> <li>University of Bologna (UNIBO), IT</li> <li>National Public Health Center (NPHC), HU</li> <li>University of P\u00e9cs (UP), HU</li> <li>University of Exeter Medical School (UNEXE), UK</li> <li>University of Vienna (UNIVIE), AT</li> <li>Science for Change (SfC), ES</li> <li>Norwegian University of Life Sciences (NMBU), NO</li> <li>Massachusetts General Hospital (MGH), US</li> <li>Harvard School of Public Health (HSPH), US</li> <li>University of Michigan (UMich), US</li> </ul>"},{"location":"project_info/#developer-lab","title":"Developer lab","text":"<p>The main developer, Robin Wydaeghe, is from the WAVES Research group at Ghent University and IMEC.</p>"},{"location":"quick_start/","title":"\ud83d\ude80 Quick Start: Your First GOLIAT Simulation","text":"<p>Welcome to GOLIAT! This guide will get you up and running with your first automated EMF dosimetry simulation in minutes. GOLIAT streamlines the entire process using Sim4Life, from scene setup to results analysis. We'll walk through a simple \"Hello World\" near-field simulation to calculate Specific Absorption Rate (SAR) in a digital human phantom.</p>"},{"location":"quick_start/#what-youll-achieve","title":"\ud83c\udfaf What you'll achieve","text":"<p>By the end of this guide, you will have: - Cloned the GOLIAT repository. - Set up your Python environment with Sim4Life integration. - Configured a basic near-field simulation. - Run your first GOLIAT study. - Understood where to find and interpret the simulation results.</p>"},{"location":"quick_start/#prerequisites","title":"\ud83d\udccb Prerequisites","text":"<p>Before you begin, please ensure you have the following:</p> <ul> <li>Sim4Life: Version 8.2.0 or later, with a valid license. If you don't have it, you can download it from ZMT Zurich.</li> <li>Python: Version 3.11+ (GOLIAT is designed to use the Python distribution bundled with Sim4Life, so a separate Python installation is usually not required).</li> <li>Digital Phantom Models: GOLIAT will automatically download necessary phantom models (e.g., \"thelonious\" for a child, \"eartha\" for an adult) on its first run. You may be prompted to provide your email for licensing purposes.</li> <li>Antenna Models: Supported antenna models for various frequencies (e.g., a 700 MHz PIFA antenna) are also auto-downloaded as needed.</li> </ul> <p>\ud83d\udca1 Pro Tip: If you're new to EMF dosimetry or Sim4Life, it's helpful to familiarize yourself with core concepts like SAR (Specific Absorption Rate \u2013 the rate at which electromagnetic energy is absorbed by biological tissue) and digital human phantoms (realistic 3D models of the human body used for simulation).</p>"},{"location":"quick_start/#step-1-clone-the-repository-and-install-dependencies","title":"Step 1: Clone the repository and install dependencies","text":"<p>First, open your terminal or command prompt and clone the GOLIAT repository:</p> <pre><code>git clone https://github.com/rwydaegh/goliat.git\ncd goliat\n</code></pre> <p>Next, install the required Python dependencies. It's crucial to use the Python environment provided by your Sim4Life installation.</p> <pre><code># 1. Source .bashrc to add Sim4Life Python to your PATH (one-time setup)\n#    Edit .bashrc in the project root if your Sim4Life path differs from the default.\nsource .bashrc\n\n# Example .bashrc content for Windows (adjust path as necessary):\n# export PATH=\"/c/Program Files/Sim4Life_8.2.0/Python:$PATH\"\n# export PYTHONPATH=\"/c/Program Files/Sim4Life_8.2.0/Python/Lib/site-packages:$PYTHONPATH\"\n\n# 2. Install Python packages\npip install -r requirements.txt\n</code></pre>"},{"location":"quick_start/#step-2-configure-your-first-study","title":"Step 2: Configure your first study","text":"<p>GOLIAT uses a flexible JSON-based configuration system located in the <code>configs/</code> directory. For your first simulation, we'll use a simple near-field configuration.</p> <ol> <li> <p>Choose a template:</p> <ul> <li>For Near-Field simulations (device close to the body), copy <code>configs/near_field_config.json</code> to <code>configs/my_first_near_field_study.json</code>.</li> <li>For Far-Field simulations (whole-body plane wave exposure), copy <code>configs/far_field_config.json</code> to <code>configs/my_first_far_field_study.json</code>.</li> </ul> </li> <li> <p>Edit your custom config (e.g., <code>configs/my_first_near_field_study.json</code>):     <pre><code>{\n  \"extends\": \"base_config.json\",\n  \"study_type\": \"near_field\",\n  \"phantoms\": [\"thelonious\"],  // We'll use the child phantom for this example\n  \"frequencies_mhz\": [700],    // A single frequency for a quick test run\n  \"execution_control\": {\n    \"do_setup\": true,\n    \"do_run\": true,\n    \"do_extract\": true\n  }\n  // GOLIAT will default to a \"by_cheek\" placement for near-field if not specified\n}\n</code></pre> Note: GOLIAT's configuration system supports inheritance. Your custom config extends <code>base_config.json</code>, allowing you to override only the settings you need. For a deep dive into all available parameters, refer to the Configuration Guide.</p> </li> <li> <p>Set Up Environment Variables: Create a <code>.env</code> file in the project root for credentials.</p> <ul> <li>For oSPARC Cloud Runs (Optional): If you plan to use oSPARC, add your API key and secret:     <pre><code>OSPARC_API_KEY=your_osparc_api_key\nOSPARC_API_SECRET=your_osparc_api_secret\n</code></pre></li> <li>For Phantom Downloads: To download phantom models, you may need to provide an email address associated with your institution's license:     <pre><code>DOWNLOAD_EMAIL=your_email@example.com\n</code></pre></li> </ul> </li> </ol>"},{"location":"quick_start/#step-3-run-your-first-simulation","title":"Step 3: Run your first simulation","text":"<p>Now you're ready to launch your first GOLIAT study! Execute the following command in your terminal:</p> <pre><code>python run_study.py --config configs/my_first_near_field_study.json\n</code></pre> <p>What to Expect: -   A GOLIAT GUI window will open, displaying real-time progress, status messages, and an estimated time of arrival (ETA). -   Behind the Scenes:     1.  GOLIAT will check for and download any required phantom and antenna models (this is a one-time process).     2.  It will then automatically build the simulation scene in Sim4Life, loading the specified phantom and placing the antenna (e.g., 8mm from the cheek).     3.  The simulation will run using the iSolve solver (locally) or be submitted to oSPARC (if configured for cloud batching).     4.  Finally, GOLIAT will extract key SAR metrics, including whole-body SAR, head/trunk SAR, and peak 10g SAR in various tissues (eyes, brain, skin). -   Duration: This initial test simulation typically takes 5-10 minutes, depending on your system and Sim4Life configuration.</p> <p>Visual Aid:  Placeholder for a screenshot of the GOLIAT GUI during a simulation run.</p>"},{"location":"quick_start/#step-4-view-and-analyze-results","title":"Step 4: View and analyze results","text":"<p>Once the simulation is complete, GOLIAT will save all results in a structured directory within the <code>results/</code> folder. For our example, you'll find outputs in <code>results/near_field/thelonious/700MHz/by_cheek/</code>.</p> <p>Key Output Files: -   <code>sar_results.json</code>: Contains normalized SAR values (e.g., mW/kg per 1W input power). -   <code>sar_stats_all_tissues.pkl</code>: A detailed Python pickle file with comprehensive tissue-specific data. -   Plots: Various plots, such as SAR heatmaps and bar charts, visualizing the results.</p> <p>You can also run the dedicated analysis script to aggregate and further process your results:</p> <p><pre><code>python run_analysis.py --config configs/my_first_near_field_study.json\n</code></pre> This will generate additional CSV files and plots in the <code>results/</code> directory.</p> <p>Example Results Plot:  Placeholder for an example plot generated by GOLIAT, showcasing SAR distribution.</p> <p>Troubleshooting: Encountering issues? Refer to the Troubleshooting Guide for common problems and solutions (e.g., Sim4Life licensing, Python path errors, disk space management).</p>"},{"location":"quick_start/#next-steps","title":"Next steps","text":"<p>Congratulations, you've successfully run your first GOLIAT simulation! Here's what you can do next:</p> <ul> <li>Customize Your Studies: Experiment with your configuration files to explore different frequencies, phantoms, and antenna placements.</li> <li>Manage Disk Space: If running multiple simulations serially, enable automatic cleanup to save space: <code>\"auto_cleanup_previous_results\": [\"output\"]</code>. See Configuration Guide.</li> <li>Scale with the Cloud: Learn how to leverage oSPARC for parallel, large-scale simulations by setting <code>\"batch_run\": true</code> in your config.</li> <li>Explore Tutorials: Dive deeper with our Basic Tutorial for more default runs, or the Advanced Tutorial for batching and complex scenarios.</li> </ul> <p>You're now simulating EMF exposure like a pro! If you have any questions or encounter further issues, please don't hesitate to open a GitHub Issue.</p>"},{"location":"technical_guide/","title":"GOLIAT Technical Guide","text":"<p>This document provides a comprehensive overview of the GOLIAT project's architecture, key components, and core functionalities. It is intended for developers who want to understand, extend, or maintain the codebase.</p>"},{"location":"technical_guide/#core-philosophy","title":"Core philosophy","text":"<p>GOLIAT is designed with a modular, configuration-driven architecture. The primary goal is to automate the entire EMF dosimetry simulation workflow, from scene setup to results analysis, while ensuring reproducibility and scalability. The system is orchestrated by Study classes, which manage the simulation lifecycle based on parameters defined in JSON configuration files. This approach allows for easy modification of simulation parameters without changing the underlying code, and it ensures that simulations can be repeated with the exact same settings.</p>"},{"location":"technical_guide/#system-architecture","title":"System architecture","text":"<p>The application is structured in several distinct layers, each with a specific responsibility. This separation of concerns makes the system easier to understand, maintain, and extend.</p> <pre><code>graph TB\n    subgraph \"User Interface Layer\"\n        GUI[GUI Manager&lt;br/&gt;PySide6]\n        CLI[Command Line]\n    end\n\n    subgraph \"Orchestration Layer\"\n        Study[Study Classes&lt;br/&gt;NearFieldStudy / FarFieldStudy]\n        Config[Configuration Manager]\n        Profiler[Profiler &amp; Progress Tracking]\n    end\n\n    subgraph \"Core Processing Layer\"\n        PM[Project Manager]\n        Setup[Setup Classes&lt;br/&gt;Scene Building]\n        Runner[Simulation Runner]\n        Extractor[Results Extractor]\n    end\n\n    subgraph \"Analysis Layer\"\n        Analyzer[Analyzer]\n        Plotter[Plotter]\n    end\n\n    subgraph \"External Services\"\n        S4L[Sim4Life Engine]\n        oSPARC[oSPARC Cloud]\n    end\n\n    GUI --&gt; Study\n    CLI --&gt; Study\n    Study --&gt; Config\n    Study --&gt; Profiler\n    Study --&gt; PM\n    Study --&gt; Setup\n    Study --&gt; Runner\n    Study --&gt; Extractor\n    Extractor --&gt; Analyzer\n    Analyzer --&gt; Plotter\n    Runner --&gt; S4L\n    Runner --&gt; oSPARC\n    Setup --&gt; S4L\n    Extractor --&gt; S4L\n\n    style GUI fill:#E1BEE7\n    style Study fill:#BBDEFB\n    style Setup fill:#C5E1A5\n    style Runner fill:#FFE082\n    style Extractor fill:#FFCCBC\n    style Analyzer fill:#D1C4E9\n    style Plotter fill:#D1C4E9</code></pre>"},{"location":"technical_guide/#workflow-and-component-interactions","title":"Workflow and component interactions","text":"<p>The simulation process follows a clear, sequential workflow, orchestrated by the <code>NearFieldStudy</code> or <code>FarFieldStudy</code> classes. This workflow ensures that each step is completed successfully before the next one begins, and it provides a clear structure for the entire simulation process.</p> <pre><code>sequenceDiagram\n    participant User\n    participant GUI\n    participant Study\n    participant Setup\n    participant Runner\n    participant Extractor\n    participant Files\n\n    User-&gt;&gt;GUI: Start Study\n    GUI-&gt;&gt;Study: Initialize\n    Study-&gt;&gt;Setup: Configure Scene\n    Setup-&gt;&gt;Files: Create .smash\n    Study-&gt;&gt;Runner: Execute Simulation\n    Runner-&gt;&gt;Files: Generate Input (.h5)\n    Runner-&gt;&gt;Runner: Run Solver\n    Runner-&gt;&gt;Files: Write Results\n    Study-&gt;&gt;Extractor: Process Results\n    Extractor-&gt;&gt;Files: Read Output\n    Extractor-&gt;&gt;Files: Save Reports\n    Study-&gt;&gt;GUI: Update Progress\n    GUI-&gt;&gt;User: Show Completion</code></pre>"},{"location":"technical_guide/#core-components","title":"Core components","text":"<p>This section details GOLIAT's core classes and their roles within the framework. For a complete API reference, please see the Full API Reference.</p>"},{"location":"technical_guide/#orchestration-layer","title":"Orchestration layer","text":""},{"location":"technical_guide/#config","title":"<code>Config</code>","text":"<ul> <li>Function: Loads and manages hierarchical JSON configurations. A study-specific config (e.g., <code>near_field_config.json</code>) extends a <code>base_config.json</code>, allowing for a clean override system. This design minimizes duplication and makes it easy to manage different simulation scenarios. The <code>Config</code> class is responsible for loading the <code>base_config.json</code> and then recursively merging the study-specific configuration over it.</li> <li>Some interesting methods:<ul> <li><code>get_setting(path, default)</code>: Retrieves nested settings using a dot-separated path.</li> <li><code>get_antenna_config()</code>: Returns antenna-specific settings.</li> <li><code>get_phantom_config(phantom_name)</code>: Returns settings for a specific phantom.</li> <li><code>_load_config_with_inheritance(path)</code>: The core method that handles the hierarchical loading of configuration files.</li> </ul> </li> <li>API Reference: src.config.Config</li> </ul>"},{"location":"technical_guide/#basestudy-nearfieldstudy-farfieldstudy","title":"<code>BaseStudy</code>, <code>NearFieldStudy</code>, <code>FarFieldStudy</code>","text":"<ul> <li>Function: Orchestrates the entire simulation workflow. <code>BaseStudy</code> provides the core structure, including the main <code>run()</code> method, logging, and profiling. <code>NearFieldStudy</code> and <code>FarFieldStudy</code> inherit from <code>BaseStudy</code> and implement the <code>_run_study()</code> method, which contains the specific logic for each study type. This inheritance-based design allows for code reuse and a clear separation of concerns.</li> <li>Some interesting methods:<ul> <li><code>run()</code>: The main entry point to execute the study. It handles top-level error handling and ensures that the necessary Sim4Life environment is running. It then calls the <code>_run_study</code> method.</li> <li><code>_run_study()</code>: This is the core of each study. It loops through phantoms, frequencies, and placements, coordinating the setup, run, and extraction phases for each simulation.</li> </ul> </li> <li>API Reference:<ul> <li>src.studies.base_study.BaseStudy</li> <li>src.studies.near_field_study.NearFieldStudy</li> <li>src.studies.far_field_study.FarFieldStudy</li> </ul> </li> </ul>"},{"location":"technical_guide/#core-processing-layer","title":"Core processing layer","text":""},{"location":"technical_guide/#projectmanager","title":"<code>ProjectManager</code>","text":"<ul> <li>Function: Manages Sim4Life project files (<code>.smash</code>). It handles file creation, opening, saving, and validation to prevent issues with file locks or corruption. This is a critical component for ensuring the stability of the simulation process. It includes a <code>_is_valid_smash_file()</code> method that checks for file locks and verifies the HDF5 structure of the project file before attempting to open it.</li> <li>Some interesting methods:<ul> <li><code>create_or_open_project(...)</code>: Creates a new project or opens an existing one based on the configuration.</li> </ul> </li> <li>API Reference: src.project_manager.ProjectManager</li> </ul>"},{"location":"technical_guide/#setup-modules-srcsetups","title":"Setup Modules (<code>src/setups/</code>)","text":"<ul> <li>Function: A collection of specialized classes, each responsible for a specific part of the scene setup in Sim4Life. All setup classes inherit from <code>BaseSetup</code>, which provides common functionalities like logging and access to the Sim4Life API. The <code>NearFieldSetup</code> and <code>FarFieldSetup</code> classes coordinate the execution of the other setup modules. This modular design makes it easy to add new setup steps or modify existing ones.</li> <li>Some components:<ul> <li><code>PhantomSetup</code>: Loads and validates phantom models.</li> <li><code>PlacementSetup</code>: Positions the antenna relative to the phantom.</li> <li><code>MaterialSetup</code>: Assigns material properties to all entities.</li> <li><code>GriddingSetup</code>: Configures the spatial grid for the simulation.</li> <li><code>BoundarySetup</code>: Sets up the boundary conditions (e.g., PML).</li> <li><code>SourceSetup</code>: Configures the EMF sources and sensors.</li> </ul> </li> <li>API Reference: src.setups</li> </ul>"},{"location":"technical_guide/#simulationrunner","title":"<code>SimulationRunner</code>","text":"<ul> <li>Function: Executes the simulation, either locally using <code>iSolve.exe</code> or by submitting it to the oSPARC cloud platform. It also handles real-time logging of the solver output. A key feature is the <code>_run_isolve_manual</code> method, which runs the solver in a separate process and uses a non-blocking reader thread to capture and log its output in real-time.</li> <li>Some interesting methods:<ul> <li><code>run_all()</code>: Iterates through and runs all simulations defined in the study.</li> </ul> </li> <li>API Reference: src.simulation_runner.SimulationRunner</li> </ul>"},{"location":"technical_guide/#resultsextractor","title":"<code>ResultsExtractor</code>","text":"<ul> <li>Function: Post-processes the simulation output. It uses a set of specialized extractor modules in the <code>src/extraction/</code> directory to pull key metrics. This modular approach makes it easy to add new extraction capabilities.</li> <li>Extractor Modules:<ul> <li><code>PowerExtractor</code>: Extracts input power and power balance.</li> <li><code>SarExtractor</code>: Extracts detailed SAR statistics for all tissues.</li> <li><code>SensorExtractor</code>: Extracts data from point sensors.</li> <li><code>Reporter</code>: Generates detailed reports in Pickle and HTML formats.</li> <li><code>Cleaner</code>: Handles cleanup of simulation files to save disk space.</li> </ul> </li> <li>Some interesting methods:<ul> <li><code>extract()</code>: Orchestrates the entire extraction process.</li> </ul> </li> <li>API Reference: src.results_extractor.ResultsExtractor</li> </ul>"},{"location":"technical_guide/#analysis-layer","title":"Analysis layer","text":""},{"location":"technical_guide/#analyzer-strategies","title":"<code>Analyzer</code> &amp; Strategies","text":"<ul> <li>Function: The <code>Analyzer</code> class orchestrates the analysis of extracted results. It uses a strategy pattern, delegating the specifics of the analysis to a <code>BaseAnalysisStrategy</code> subclass (<code>NearFieldAnalysisStrategy</code> or <code>FarFieldAnalysisStrategy</code>). This design allows for different analysis workflows to be implemented without changing the core <code>Analyzer</code> logic. The strategy is responsible for loading the correct data, calculating summary statistics, and generating the appropriate plots.</li> <li>Some interesting methods:<ul> <li><code>run_analysis()</code>: Loads results, applies the strategy, and generates reports and plots.</li> </ul> </li> <li>API Reference:<ul> <li>src.analysis.analyzer.Analyzer</li> <li>src.analysis.base_strategy.BaseAnalysisStrategy</li> </ul> </li> </ul>"},{"location":"technical_guide/#plotter","title":"<code>Plotter</code>","text":"<ul> <li>Function: Generates a variety of plots from the analyzed data. It is designed to be a flexible component that can be easily extended to create new types of visualizations.</li> <li>Some interesting methods:<ul> <li><code>plot_sar_heatmap(...)</code>: Creates a heatmap of SAR distribution by tissue.</li> <li><code>plot_average_sar_bar(...)</code>: Generates a bar chart of average SAR values.</li> <li><code>plot_pssar_line(...)</code>: Creates a line plot of peak spatial-average SAR.</li> <li><code>plot_sar_distribution_boxplots(...)</code>: Generates boxplots to show the distribution of SAR values.</li> </ul> </li> <li>API Reference: src.analysis.plotter.Plotter</li> </ul>"},{"location":"technical_guide/#advanced-features","title":"Advanced features","text":"<p>For a deep dive about the advanced features, refer to the Advanced Features Guide</p>"},{"location":"technical_guide/#gui-and-multiprocessing","title":"GUI and multiprocessing","text":"<p>The application employs a multi-process architecture to ensure a responsive user experience, even during long-running simulations.</p> <ul> <li>Main Process: A lightweight PySide6 GUI (<code>ProgressGUI</code>) is launched. This GUI is responsible for displaying progress, logs, and timing information.</li> <li>Study Process: The actual study (<code>NearFieldStudy</code> or <code>FarFieldStudy</code>) is executed in a separate process using Python's <code>multiprocessing</code> module. This prevents the GUI from freezing during intensive calculations.</li> <li>Communication: The study process communicates with the GUI process through a <code>multiprocessing.Queue</code>. It sends messages containing status updates, progress information, and timing data.</li> </ul> <p>The entry point for the study process is the <code>study_process_wrapper</code> function in <code>run_study.py</code>, which sets up a special <code>QueueGUI</code> object. This object mimics the real GUI's interface but directs all its output to the shared queue.</p>"},{"location":"technical_guide/#logging","title":"Logging","text":"<p>The system uses Python's standard <code>logging</code> module, configured to provide two distinct streams of information:</p> <ul> <li><code>progress</code> logger: For high-level, user-facing messages. These are shown in the GUI and saved to <code>*.progress.log</code>.</li> <li><code>verbose</code> logger: For detailed, internal messages. These are saved to the main <code>*.log</code> file.</li> </ul> <p>The <code>setup_loggers</code> function in <code>src/logging_manager.py</code> handles log rotation to prevent excessive disk usage.</p>"},{"location":"technical_guide/#profiling-and-timing","title":"Profiling and timing","text":"<p>The <code>Profiler</code> class in <code>src/profiler.py</code> is the engine for the timing and progress estimation system.</p> <ul> <li>Phases and Weights: A study is divided into phases (<code>setup</code>, <code>run</code>, <code>extract</code>). <code>profiling_config.json</code> assigns a \"weight\" to each, representing its contribution to the total time.</li> <li>Dynamic Weights: The profiler normalizes these weights based on which phases are active.</li> <li>Time Estimation (ETA): The <code>get_time_remaining</code> method is adaptive. Initially, it relies on historical estimates. Once one or more stages have completed, it switches to a more accurate method based on the actual average time taken per stage.</li> <li>Self-Improving Estimates: After a run, <code>save_estimates</code> calculates the average time for each timed subtask and writes these new averages back to <code>profiling_config.json</code>.</li> </ul> <p>For a complete and detailed API reference, please refer to the Full API Reference.</p>"},{"location":"troubleshooting/","title":"Troubleshooting","text":"<p>This section addresses common issues encountered when using GOLIAT. Issues are grouped by category, with steps to resolve them.</p>"},{"location":"troubleshooting/#sim4life-setup-issues","title":"Sim4life setup issues","text":""},{"location":"troubleshooting/#sim4life-not-found-or-python-path-error","title":"Sim4life not found or python path error","text":"<ul> <li>Symptom: \"iSolve.exe not found\" or import errors for s4l_v1.</li> <li>Cause: Sim4Life Python not in PATH.</li> <li>Solution:</li> <li>Locate Sim4Life installation (default: C:\\Program Files\\Sim4Life_8.2.0).</li> <li>Edit <code>.bashrc</code> in project root with your path:      <pre><code>export PATH=\"/path/to/Sim4Life/Python:$PATH\"\n</code></pre></li> <li>Source: <code>source .bashrc</code>.</li> <li>Verify: <code>python -c \"import s4l_v1; print('OK')\"</code> \u2013 should print \"OK\".</li> </ul>"},{"location":"troubleshooting/#sim4life-license-or-phantom-download-fails","title":"Sim4life license or phantom download fails","text":"<ul> <li>Symptom: \"License error\" or phantom download prompt fails.</li> <li>Cause: Missing license or invalid email.</li> <li>Solution:</li> <li>Ensure Sim4Life is licensed (check via GUI).</li> <li>Update <code>download_email</code> in <code>configs/base_config.json</code> (e.g., \"your@email.com\").</li> <li>Rerun study \u2013 GOLIAT retries download.</li> <li>Manual alternative: Download phantoms from ZMT Zurich site, place in <code>data/</code>.</li> </ul>"},{"location":"troubleshooting/#project-and-file-issues","title":"Project and file issues","text":""},{"location":"troubleshooting/#lock-files-prevent-access","title":"Lock files prevent access","text":"<ul> <li>Symptom: \"File locked\" or \"Project corruption\" error.</li> <li>Cause: A previous run crashed, leaving a lock file behind. This is a hidden file with a <code>.s4l_lock</code> extension.</li> <li>Solution:</li> <li>Close all Sim4Life instances.</li> <li>Manually delete the lock file. It will be in the same directory as the <code>.smash</code> file.</li> <li>Rerun the simulation. If the issue persists, restarting your machine may be necessary.</li> </ul>"},{"location":"troubleshooting/#corrupted-project-file-smash","title":"Corrupted project file (.smash)","text":"<ul> <li>Symptom: \"HDF5 format error\" or \"Could not open project\".</li> <li>Cause: Incomplete save or disk issue.</li> <li>Solution:</li> <li>Set <code>\"do_setup\": true</code> in your configuration file. GOLIAT will automatically overwrite the corrupted file with a new one.</li> <li>Check disk space/logs for hardware issues.</li> </ul>"},{"location":"troubleshooting/#execution-issues","title":"Execution issues","text":""},{"location":"troubleshooting/#simulation-run-fails-isolveexe","title":"Simulation run fails (iSolve.exe)","text":"<ul> <li>Symptom: \"iSolve.exe failed with return code\" or no output.</li> <li>Cause: Path, kernel (Acceleware/CUDA), or input file issue.</li> <li>Solution:</li> <li>Verify iSolve path in code (src/simulation_runner.py).</li> <li>Try <code>\"kernel\": \"Software\"</code> in config for CPU fallback.</li> <li>Check <code>logs/*.log</code> for solver errors (e.g., grid too fine).</li> <li>Ensure <code>manual_isolve: true</code> in config.</li> </ul>"},{"location":"troubleshooting/#osparc-batch-submission-fails","title":"oSPARC batch submission fails","text":"<ul> <li>Symptom: \"Invalid API key\" or \"Job failed\".</li> <li>Cause: .env missing/invalid or quota exceeded.</li> <li>Solution:</li> <li>Verify <code>.env</code> in root (OSPARC_API_KEY etc.; see User Guide).</li> <li>Test keys: Run a single cloud sim first.</li> <li>Check quotas in oSPARC dashboard (max ~61 jobs).</li> <li>For \"RETRYING\": Code auto-retries 3 times; check logs/osparc_submission_logs/.</li> <li>Cancel stuck jobs: <code>python scripts/cancel_all_jobs.py --config your_config.json</code>.</li> </ul>"},{"location":"troubleshooting/#no-results-extracted","title":"No results extracted","text":"<ul> <li>Symptom: Empty JSON/PKL or \"No SAR data\".</li> <li>Cause: <code>do_extract: false</code> or simulation failed.</li> <li>Solution:</li> <li>Set <code>\"do_extract\": true</code> in config.</li> <li>Verify simulation completed (check power_balance ~100%).</li> <li>Rerun extraction: <code>\"do_setup\": false, \"do_run\": false, \"do_extract\": true</code>.</li> </ul>"},{"location":"troubleshooting/#configuration-issues","title":"Configuration issues","text":""},{"location":"troubleshooting/#config-loading-error","title":"Config loading error","text":"<ul> <li>Symptom: \"File not found\" or \"Unknown study_type\".</li> <li>Cause: Invalid path or missing <code>study_type</code>.</li> <li>Solution:</li> <li>Use full path: <code>--config configs/near_field_config.json</code>.</li> <li>Ensure <code>study_type</code>: \"near_field\" or \"far_field\".</li> <li>Validate your JSON syntax. For a detailed guide on the configuration options, see the Configuration Documentation.</li> </ul>"},{"location":"troubleshooting/#placement-or-antenna-not-found","title":"Placement or antenna not found","text":"<ul> <li>Symptom: \"Could not find component\" or invalid placement.</li> <li>Cause: Custom config mismatch.</li> <li>Solution:</li> <li>Use default configs first.</li> <li>For custom, match <code>placement_scenarios</code> keys exactly.</li> <li>Antenna: Ensure freq in <code>antenna_config</code> keys.</li> </ul>"},{"location":"troubleshooting/#gui-and-logging-issues","title":"Gui and logging issues","text":""},{"location":"troubleshooting/#gui-freezes-or-no-progress","title":"Gui freezes or no progress","text":"<ul> <li>Symptom: Window unresponsive.</li> <li>Cause: Multiprocessing issue or long computation.</li> <li>Solution:</li> <li>Run headless: Set <code>\"use_gui\": false</code> in your config and run <code>python run_study.py --config your_config.json</code>.</li> <li>Check <code>logs/*.progress.log</code> for updates.</li> <li>Reduce grid size for faster tests.</li> </ul>"},{"location":"troubleshooting/#logs-not-generating","title":"Logs not generating","text":"<ul> <li>Symptom: Empty <code>logs/</code> or no output.</li> <li>Cause: Permissions or rotation lock.</li> <li>Solution:</li> <li>Check permissions: <code>chmod -R 755 logs/</code>.</li> <li>Delete stale locks: <code>rm logs/log_rotation.lock</code>.</li> <li>Run with <code>--pid 1</code> for unique logs.</li> </ul>"},{"location":"troubleshooting/#disk-space-issues","title":"Disk space issues","text":""},{"location":"troubleshooting/#running-out-of-disk-space","title":"Running out of disk space","text":"<ul> <li>Symptom: \"No space left on device\" or simulation failures.</li> <li>Cause: Large simulation output files accumulating.</li> <li>Solution:</li> <li>Enable automatic cleanup for serial workflows:      <pre><code>\"execution_control\": {\n  \"auto_cleanup_previous_results\": [\"output\"]\n}\n</code></pre></li> <li>Manually delete old <code>*_Output.h5</code>, <code>*_Input.h5</code> files from <code>results/</code> directories.</li> <li>Archive completed studies to external storage.</li> <li>See Configuration Guide for cleanup options.</li> </ul>"},{"location":"troubleshooting/#general-tips","title":"General tips","text":"<ul> <li>Always check <code>logs/</code> and console for errors.</li> <li>Rerun phases individually using <code>execution_control</code>.</li> <li>For cloud: Monitor oSPARC dashboard for job details.</li> <li>For disk space: Use <code>auto_cleanup_previous_results</code> in serial workflows.</li> <li>Still stuck? Open GitHub Issue with log snippet.</li> </ul> <p>See User Guide for workflows.</p>"},{"location":"uml/","title":"UML Diagrams","text":"<p>These diagrams are generated from the Python sources under <code>src/</code> using Pyreverse (from Pylint). The generator script is <code>scripts/generate_uml.py</code>.</p> Class Diagram Could not retrieve image data, got: Forbidden [403]<p></p><pre><code>@startuml classes_GOLIAT\nskinparam linetype poly\nskinparam ranksep 300\nset namespaceSeparator none\nclass \"Analyzer\" as src.analysis.analyzer.Analyzer {\n  all_organ_results : list\n  all_results : list\n  base_dir\n  config : str\n  phantom_name : str\n  plotter\n  results_base_dir\n  strategy : str\n  tissue_group_definitions : dict\n  __init__(config: 'Config', phantom_name: str, strategy: 'BaseAnalysisStrategy')\n  _convert_units_and_cache(results_df: pd.DataFrame, organ_results_df: pd.DataFrame) -&gt; pd.DataFrame\n  _export_reports(results_df: pd.DataFrame, all_organ_results_df: pd.DataFrame)\n  _generate_plots(results_df: pd.DataFrame, all_organ_results_df: pd.DataFrame)\n  _process_single_result(frequency_mhz: int, scenario_name: str, pos_name: str, orient_name: str)\n  run_analysis()\n}\nclass \"Antenna\" as src.antenna.Antenna {\n  antenna_config\n  config : str\n  frequency_mhz : int\n  __init__(config: 'Config', frequency_mhz: int)\n  get_centered_antenna_path(centered_antennas_dir: str) -&gt; str\n  get_config_for_frequency() -&gt; dict\n  get_model_type() -&gt; str\n  get_source_entity_name() -&gt; str\n}\nclass \"BaseAnalysisStrategy\" as src.analysis.base_strategy.BaseAnalysisStrategy {\n  base_dir\n  config : str\n  phantom_name : str\n  __init__(config: 'Config', phantom_name: str)\n  {abstract}apply_bug_fixes(result_entry: dict) -&gt; dict\n  {abstract}calculate_summary_stats(results_df: pd.DataFrame) -&gt; pd.DataFrame\n  {abstract}extract_data(pickle_data: dict, frequency_mhz: int, detailed_name: str, scenario_name: str, sim_power: float, norm_factor: float) -&gt; tuple[dict, list]\n  {abstract}generate_plots(analyzer: 'Analyzer', plotter: 'Plotter', results_df: pd.DataFrame, all_organ_results_df: pd.DataFrame)\n  {abstract}get_normalization_factor(frequency_mhz: int, simulated_power_w: float) -&gt; float\n  {abstract}get_plots_dir() -&gt; str\n  {abstract}get_results_base_dir() -&gt; str\n  {abstract}load_and_process_results(analyzer: 'Analyzer')\n}\nclass \"BaseAnalysisStrategy\" as src.analysis.strategies.BaseAnalysisStrategy {\n  base_dir\n  config\n  phantom_name\n  __init__(config, phantom_name)\n  {abstract}apply_bug_fixes(result_entry)\n  {abstract}calculate_summary_stats(results_df)\n  {abstract}extract_data(pickle_data, frequency_mhz, detailed_name, scenario_name, sim_power, norm_factor)\n  {abstract}generate_plots(analyzer, plotter, results_df, all_organ_results_df)\n  {abstract}get_normalization_factor(frequency_mhz, simulated_power_w)\n  {abstract}get_plots_dir()\n  {abstract}get_results_base_dir()\n  {abstract}load_and_process_results(analyzer)\n}\nclass \"BaseSetup\" as src.setups.base_setup.BaseSetup {\n  config : str\n  emfdtd\n  model\n  progress_logger : str\n  s4l_v1\n  verbose_logger : str\n  __init__(config: 'Config', verbose_logger: 'Logger', progress_logger: 'Logger')\n  _add_point_sensors(simulation: 'emfdtd.Simulation', sim_bbox_entity_name: str)\n  _apply_simulation_time_and_termination(simulation: 'emfdtd.Simulation', sim_bbox_entity: 'model.Entity', frequency_mhz: int)\n  _finalize_setup(project_manager: 'ProjectManager', simulation: 'emfdtd.Simulation', all_simulation_parts: list, frequency_mhz: int)\n  _setup_solver_settings(simulation: 'emfdtd.Simulation')\n  {abstract}run_full_setup(project_manager: 'ProjectManager')\n}\nclass \"BaseStudy\" as src.studies.base_study.BaseStudy {\n  base_dir\n  config\n  gui : str\n  line_profiler : NoneType\n  profiler\n  progress_logger : NoneType, RootLogger\n  project_manager\n  study_type : str\n  verbose_logger : NoneType, RootLogger\n  __init__(study_type: str, config_filename: str, gui: 'QueueGUI', profiler)\n  _check_for_stop_signal()\n  {abstract}_run_study()\n  _setup_line_profiler(subtask_name: str, instance) -&gt; tuple\n  end_stage_animation()\n  run()\n  start_stage_animation(task_name: str, end_value: int)\n  subtask(task_name: str, instance_to_profile)\n}\nclass \"BatchGUI\" as src.osparc_batch.gui.BatchGUI {\n  button_layout\n  cancel_jobs_requested\n  force_stop_button\n  layout\n  print_progress_requested\n  progress_button\n  stop_and_cancel_button\n  stop_run_requested\n  tray_button\n  tray_icon\n  __init__()\n  closeEvent(event)\n  force_stop_run()\n  hide_to_tray()\n  init_ui()\n  show_from_tray()\n  stop_and_cancel_jobs()\n  tray_icon_activated(reason)\n}\nclass \"BoundarySetup\" as src.setups.boundary_setup.BoundarySetup {\n  simulation : str\n  __init__(config: 'Config', simulation: 'emfdtd.Simulation', verbose_logger: 'Logger', progress_logger: 'Logger')\n  setup_boundary_conditions()\n}\nclass \"Cleaner\" as src.extraction.cleaner.Cleaner {\n  parent : str\n  __init__(parent: 'ResultsExtractor')\n  _delete_files(cleanup_types: list, file_patterns: dict) -&gt; int\n  _delete_single_file(file_path: str) -&gt; bool\n  cleanup_simulation_files()\n}\nclass \"ColorFormatter\" as src.logging_manager.ColorFormatter {\n  format(record: logging.LogRecord) -&gt; str\n}\nclass \"Config\" as src.config.Config &lt;&gt; {\n  base_dir : str\n  config\n  config_path\n  material_mapping\n  material_mapping_path\n  profiling_config\n  profiling_config_path\n  __init__(base_dir: str, config_filename: str)\n  _load_config_with_inheritance(path: str) -&gt; dict\n  _load_json(path: str) -&gt; dict\n  _resolve_config_path(config_filename: str, base_path: str) -&gt; str\n  get_antenna_component_names(antenna_model_type: str) -&gt; list\n  get_antenna_config() -&gt; dict\n  get_auto_cleanup_previous_results() -&gt; list\n  get_bandwidth() -&gt; float\n  get_download_email() -&gt; str\n  get_excitation_type() -&gt; str\n  get_freespace_expansion() -&gt; list\n  get_gridding_parameters() -&gt; dict\n  get_line_profiling_config() -&gt; dict\n  get_manual_isolve() -&gt; bool\n  get_material_mapping(phantom_name: str) -&gt; dict\n  get_only_write_input_file() -&gt; bool\n  get_osparc_credentials() -&gt; dict\n  get_phantom_definition(phantom_name: str) -&gt; dict\n  get_placement_scenario(scenario_name: str) -&gt; dict\n  get_profiling_config(study_type: str) -&gt; dict\n  get_setting(path: str, default)\n  get_simulation_parameters() -&gt; dict\n  get_solver_settings() -&gt; dict\n}\nclass \"FarFieldAnalysisStrategy\" as src.analysis.far_field_strategy.FarFieldAnalysisStrategy {\n  apply_bug_fixes(result_entry: dict) -&gt; dict\n  calculate_summary_stats(results_df: pd.DataFrame) -&gt; pd.DataFrame\n  extract_data(pickle_data: dict, frequency_mhz: int, placement_name: str, scenario_name: str, sim_power: float, norm_factor: float) -&gt; tuple[dict, list]\n  generate_plots(analyzer: 'Analyzer', plotter: 'Plotter', results_df: pd.DataFrame, all_organ_results_df: pd.DataFrame)\n  get_normalization_factor(frequency_mhz: int, simulated_power_w: float) -&gt; float\n  get_plots_dir() -&gt; str\n  get_results_base_dir() -&gt; str\n  load_and_process_results(analyzer: 'Analyzer')\n}\nclass \"FarFieldAnalysisStrategy\" as src.analysis.strategies.FarFieldAnalysisStrategy {\n  apply_bug_fixes(result_entry)\n  calculate_summary_stats(results_df)\n  extract_data(pickle_data, frequency_mhz, placement_name, scenario_name, sim_power, norm_factor)\n  generate_plots(analyzer, plotter, results_df, all_organ_results_df)\n  get_normalization_factor(frequency_mhz, simulated_power_w)\n  get_plots_dir()\n  get_results_base_dir()\n  load_and_process_results(analyzer)\n}\nclass \"FarFieldSetup\" as src.setups.far_field_setup.FarFieldSetup {\n  direction_name : str\n  document\n  frequency_mhz : int\n  phantom_name : str\n  polarization_name : str\n  project_manager : str\n  simulation_type\n  __init__(config: 'Config', phantom_name: str, frequency_mhz: int, direction_name: str, polarization_name: str, project_manager: 'ProjectManager', verbose_logger: 'Logger', progress_logger: 'Logger')\n  _apply_common_settings(simulation: 'emfdtd.Simulation')\n  _create_or_get_simulation_bbox() -&gt; 'model.Entity'\n  _create_simulation_entity(bbox_entity: 'model.Entity') -&gt; 'emfdtd.Simulation'\n  _finalize_setup(project_manager: 'ProjectManager', simulation: 'emfdtd.Simulation', frequency_mhz: int)\n  run_full_setup(phantom_setup: 'PhantomSetup') -&gt; 'emfdtd.Simulation'\n}\nclass \"FarFieldStudy\" as src.studies.far_field_study.FarFieldStudy {\n  __init__(config_filename: str, gui: 'QueueGUI')\n  _extract_results_for_project(phantom_name: str, freq: int, simulations_to_extract: list)\n  _run_study()\n  _validate_auto_cleanup_config(do_setup: bool, do_run: bool, do_extract: bool, auto_cleanup: list)\n}\nclass \"GriddingSetup\" as src.setups.gridding_setup.GriddingSetup {\n  antenna : str\n  frequency_mhz : Optional[int]\n  placement_name : str\n  simulation : str\n  units\n  __init__(config: 'Config', simulation: 'emfdtd.Simulation', placement_name: str, antenna: 'Antenna', verbose_logger: 'Logger', progress_logger: 'Logger', frequency_mhz: Optional[int])\n  _setup_main_grid()\n  _setup_subgrids(antenna_components: dict)\n  setup_gridding(antenna_components: dict)\n}\nclass \"LoggingMixin\" as src.logging_manager.LoggingMixin {\n  _log(message: str, level: str, log_type: str)\n}\nclass \"MaterialSetup\" as src.setups.material_setup.MaterialSetup {\n  XCoreModeling\n  antenna : str\n  database\n  free_space : bool\n  phantom_name : str\n  simulation : str\n  __init__(config: 'Config', simulation: 'emfdtd.Simulation', antenna: 'Antenna', phantom_name: str, verbose_logger: 'Logger', progress_logger: 'Logger', free_space: bool)\n  _assign_antenna_materials(antenna_components: dict)\n  _assign_phantom_materials()\n  assign_materials(antenna_components: dict, phantom_only: bool)\n}\nclass \"NearFieldAnalysisStrategy\" as src.analysis.near_field_strategy.NearFieldAnalysisStrategy {\n  apply_bug_fixes(result_entry: dict) -&gt; dict\n  calculate_summary_stats(results_df: pd.DataFrame) -&gt; pd.DataFrame\n  extract_data(pickle_data: dict, frequency_mhz: int, placement_name: str, scenario_name: str, sim_power: float, norm_factor: float) -&gt; tuple[dict, list]\n  generate_plots(analyzer: 'Analyzer', plotter: 'Plotter', results_df: pd.DataFrame, all_organ_results_df: pd.DataFrame)\n  get_normalization_factor(frequency_mhz: int, simulated_power_w: float) -&gt; float\n  get_plots_dir() -&gt; str\n  get_results_base_dir() -&gt; str\n  load_and_process_results(analyzer: 'Analyzer')\n}\nclass \"NearFieldAnalysisStrategy\" as src.analysis.strategies.NearFieldAnalysisStrategy {\n  apply_bug_fixes(result_entry)\n  calculate_summary_stats(results_df)\n  extract_data(pickle_data, frequency_mhz, placement_name, scenario_name, sim_power, norm_factor)\n  generate_plots(analyzer, plotter, results_df, all_organ_results_df)\n  get_normalization_factor(frequency_mhz, simulated_power_w)\n  get_plots_dir()\n  get_results_base_dir()\n  load_and_process_results(analyzer)\n}\nclass \"NearFieldSetup\" as src.setups.near_field_setup.NearFieldSetup {\n  XCoreModeling\n  antenna : str\n  base_placement_name : str\n  document\n  free_space : bool\n  frequency_mhz : int\n  orientation_name : str\n  phantom_name : str\n  placement_name : str\n  position_name : str\n  __init__(config: 'Config', phantom_name: str, frequency_mhz: int, scenario_name: str, position_name: str, orientation_name: str, antenna: 'Antenna', verbose_logger: 'Logger', progress_logger: 'Logger', free_space: bool)\n  _create_simulation_bbox()\n  _finalize_setup(project_manager: 'ProjectManager', simulation: 'emfdtd.Simulation', antenna_components: dict)\n  _get_antenna_components() -&gt; dict\n  _setup_bounding_boxes()\n  _setup_simulation_entity() -&gt; 'emfdtd.Simulation'\n  run_full_setup(project_manager: 'ProjectManager', lock) -&gt; 'emfdtd.Simulation'\n}\nclass \"NearFieldStudy\" as src.studies.near_field_study.NearFieldStudy {\n  __init__(config_filename: str, gui: 'QueueGUI')\n  _run_placement(phantom_name: str, freq: int, scenario_name: str, position_name: str, orientation_name: str, do_setup: bool, do_run: bool, do_extract: bool)\n  _run_study()\n  _validate_auto_cleanup_config(do_setup: bool, do_run: bool, do_extract: bool, auto_cleanup: list)\n}\nclass \"NumpyArrayEncoder\" as src.extraction.json_encoder.NumpyArrayEncoder {\n  default(obj: Any) -&gt; Any\n}\nclass \"PhantomSetup\" as src.setups.phantom_setup.PhantomSetup {\n  XCoreModeling\n  data\n  model\n  phantom_name : str\n  __init__(config: 'Config', phantom_name: str, verbose_logger: 'Logger', progress_logger: 'Logger')\n  _log(message: str, log_type: str)\n  ensure_phantom_is_loaded() -&gt; bool\n}\nclass \"PlacementSetup\" as src.setups.placement_setup.PlacementSetup {\n  XCoreMath\n  antenna : str\n  base_placement_name : str\n  free_space : bool\n  frequency_mhz : int\n  orientation_name : str\n  phantom_name : str\n  placement_name : str\n  position_name : str\n  __init__(config: 'Config', phantom_name: str, frequency_mhz: int, scenario_name: str, position_name: str, orientation_name: str, antenna: 'Antenna', verbose_logger: 'Logger', progress_logger: 'Logger', free_space: bool)\n  _get_placement_details() -&gt; tuple\n  place_antenna()\n}\nclass \"Plotter\" as src.analysis.plotter.Plotter {\n  plots_dir : str\n  __init__(plots_dir: str)\n  _plot_heatmap(fig, ax, data: pd.DataFrame, title: str, cbar: bool, cbar_ax)\n  plot_average_sar_bar(scenario_name: str, avg_results: pd.DataFrame, progress_info: pd.Series)\n  plot_far_field_distribution_boxplot(results_df: pd.DataFrame, metric: str)\n  plot_peak_sar_heatmap(organ_df: pd.DataFrame, group_df: pd.DataFrame, tissue_groups: dict, value_col: str, title: str)\n  plot_peak_sar_line(summary_stats: pd.DataFrame)\n  plot_pssar_line(scenario_name: str, avg_results: pd.DataFrame)\n  plot_sar_distribution_boxplots(scenario_name: str, scenario_results_df: pd.DataFrame)\n  plot_sar_heatmap(organ_df: pd.DataFrame, group_df: pd.DataFrame, tissue_groups: dict)\n  plot_whole_body_sar_bar(avg_results: pd.DataFrame)\n}\nclass \"PowerExtractor\" as src.extraction.power_extractor.PowerExtractor {\n  config\n  document\n  frequency_mhz\n  parent : str\n  placement_name\n  progress_logger\n  results_data : dict\n  simulation\n  study_type\n  verbose_logger\n  __init__(parent: 'ResultsExtractor', results_data: dict)\n  _extract_far_field_power()\n  _extract_near_field_power(simulation_extractor: 'analysis.Extractor')\n  extract_input_power(simulation_extractor: 'analysis.Extractor')\n  extract_power_balance(simulation_extractor: 'analysis.Extractor')\n}\nclass \"Profiler\" as src.profiler.Profiler {\n  completed_phases : set\n  completed_simulations : int\n  completed_stages_in_phase : int\n  config_path : str\n  current_phase : NoneType, str\n  current_project : int\n  execution_control : dict\n  phase_start_time : NoneType\n  phase_weights : dict\n  profiling_config : dict\n  run_phase_total_duration : int\n  start_time\n  study_type : str\n  subtask_stack : list\n  subtask_times : defaultdict\n  total_projects : int\n  total_simulations : int\n  total_stages_in_phase : int\n  __init__(execution_control: dict, profiling_config: dict, study_type: str, config_path: str)\n  _calculate_phase_weights() -&gt; dict\n  complete_run_phase()\n  end_stage()\n  get_subtask_estimate(task_name: str) -&gt; float\n  get_time_remaining(current_stage_progress: float) -&gt; float\n  get_weighted_progress(phase_name: str, phase_progress_ratio: float) -&gt; float\n  save_estimates()\n  set_current_project(project_index: int)\n  set_project_scope(total_projects: int)\n  set_total_simulations(total: int)\n  start_stage(phase_name: str, total_stages: int)\n  update_and_save_estimates()\n}\nclass \"Profiler\" as src.utils.Profiler {\n  completed_runs : int\n  config_path : str\n  current_run_start_time : NoneType\n  profiling_config\n  run_times : list\n  start_time\n  study_type : str\n  total_runs : int\n  __init__(config_path: str, study_type: str)\n  _load_config() -&gt; dict\n  end_run()\n  get_average_run_time() -&gt; float\n  get_elapsed() -&gt; float\n  get_time_remaining() -&gt; float\n  save_estimates()\n  start_run()\n  start_study(total_runs: int)\n  subtask(name: str)\n}\nclass \"ProgressGUI\" as src.gui_manager.ProgressGUI {\n  animation_active : bool\n  animation_duration : float, int\n  animation_end_value : int\n  animation_start_time : int\n  animation_start_value : int\n  animation_timer\n  button_layout\n  clock_timer\n  elapsed_label\n  eta_label\n  grid_layout\n  layout\n  overall_progress_bar\n  overall_progress_label\n  phase_name_map : dict\n  process\n  profiler\n  profiler_phase : NoneType\n  progress_logger : NoneType, RootLogger\n  queue : str\n  queue_timer\n  stage_label\n  stage_progress_bar\n  start_time\n  status_log_label\n  status_text\n  stop_button\n  stop_event : str\n  total_steps_for_stage : int\n  tray_button\n  tray_icon\n  verbose_logger : NoneType, RootLogger\n  window_title : str\n  __init__(queue: 'Queue', stop_event: 'Event', process, window_title: str)\n  closeEvent(event)\n  end_stage_animation()\n  hide_to_tray()\n  init_ui()\n  process_queue()\n  show_from_tray()\n  start_stage_animation(estimated_duration: float, end_step: int)\n  stop_study()\n  study_finished(error: bool)\n  tray_icon_activated(reason)\n  update_animation()\n  update_clock()\n  update_overall_progress(current_step: int, total_steps: int)\n  update_stage_progress(stage_name: str, current_step: int, total_steps: int)\n  update_status(message: str, log_type: str)\n}\nclass \"ProjectCorruptionError\" as src.project_manager.ProjectCorruptionError {\n}\nclass \"ProjectManager\" as src.project_manager.ProjectManager {\n  config : str\n  document\n  execution_control\n  gui : str\n  progress_logger : str\n  project_path : NoneType\n  verbose_logger : str\n  __init__(config: 'Config', verbose_logger: 'Logger', progress_logger: 'Logger', gui: 'QueueGUI')\n  _is_valid_smash_file() -&gt; bool\n  cleanup()\n  close()\n  create_new()\n  create_or_open_project(phantom_name: str, frequency_mhz: int, scenario_name: str, position_name: str, orientation_name: str)\n  open()\n  reload_project()\n  save()\n}\nclass \"QueueGUI\" as src.gui_manager.QueueGUI {\n  profiler : str\n  progress_logger : str\n  queue : str\n  stop_event : str\n  verbose_logger : str\n  __init__(queue: 'Queue', stop_event: 'Event', profiler: 'Profiler', progress_logger: 'Logger', verbose_logger: 'Logger')\n  end_stage_animation()\n  is_stopped() -&gt; bool\n  log(message: str, level: str, log_type: str)\n  {abstract}process_events()\n  start_stage_animation(task_name: str, end_value: int)\n  update_overall_progress(current_step: int, total_steps: int)\n  update_profiler()\n  update_stage_progress(stage_name: str, current_step: int, total_steps: int)\n}\nclass \"Reporter\" as src.extraction.reporter.Reporter {\n  parent : str\n  __init__(parent: 'ResultsExtractor')\n  _build_html_content(df: pd.DataFrame, tissue_groups: dict, group_sar_stats: dict, results_data: dict) -&gt; str\n  _get_results_dir() -&gt; str\n  _save_html_report(results_dir: str, df: pd.DataFrame, tissue_groups: dict, group_sar_stats: dict, results_data: dict)\n  _save_pickle_report(results_dir: str, df: pd.DataFrame, tissue_groups: dict, group_sar_stats: dict, results_data: dict)\n  save_reports(df: pd.DataFrame, tissue_groups: dict, group_sar_stats: dict, results_data: dict)\n}\nclass \"ResultsExtractor\" as src.results_extractor.ResultsExtractor {\n  analysis\n  config : str\n  document\n  free_space : bool\n  frequency_mhz : int\n  gui : str\n  orientation_name : str\n  phantom_name : str\n  placement_name : str\n  progress_logger : str\n  simulation : str\n  study : str\n  study_type : str\n  units\n  verbose_logger : str\n  __init__(config: 'Config', simulation: 's4l_v1.simulation.emfdtd.Simulation', phantom_name: str, frequency_mhz: int, scenario_name: str, position_name: str, orientation_name: str, study_type: str, verbose_logger: 'Logger', progress_logger: 'Logger', free_space: bool, gui: 'QueueGUI', study: 'BaseStudy')\n  _save_json_results(results_data: dict)\n  extract()\n}\nclass \"SarExtractor\" as src.extraction.sar_extractor.SarExtractor {\n  analysis\n  config\n  document\n  parent : str\n  phantom_name\n  placement_name\n  progress_logger\n  results_data : dict\n  simulation\n  units\n  verbose_logger\n  __init__(parent: 'ResultsExtractor', results_data: dict)\n  _calculate_group_sar(df: pd.DataFrame, tissue_groups: dict) -&gt; dict\n  _define_tissue_groups(available_tissues: list) -&gt; dict\n  extract_peak_sar_details(em_sensor_extractor: 'analysis.Extractor')\n  extract_sar_statistics(simulation_extractor: 'analysis.Extractor')\n}\nclass \"SensorExtractor\" as src.extraction.sensor_extractor.SensorExtractor {\n  parent : str\n  progress_logger\n  results_data : dict\n  verbose_logger\n  __init__(parent: 'ResultsExtractor', results_data: dict)\n  _save_plot(fig, ax)\n  extract_point_sensor_data(simulation_extractor: 'analysis.Extractor')\n}\nclass \"SimulationRunner\" as src.simulation_runner.SimulationRunner &lt;&gt; {\n  config : str\n  document\n  gui : str\n  progress_logger : str\n  project_path : str\n  simulations : list\n  study : str\n  verbose_logger : str\n  __init__(config: 'Config', project_path: str, simulations: Union['s4l_v1.simulation.emfdtd.Simulation', List['s4l_v1.simulation.emfdtd.Simulation']], verbose_logger: 'Logger', progress_logger: 'Logger', gui: 'QueueGUI', study: 'BaseStudy')\n  _get_server_id(server_name: str) -&gt; str\n  _run_isolve_manual(simulation: 's4l_v1.simulation.emfdtd.Simulation')\n  _run_osparc_direct(simulation: 's4l_v1.simulation.emfdtd.Simulation', server_name: str)\n  run(simulation: 's4l_v1.simulation.emfdtd.Simulation')\n  run_all()\n}\nclass \"SourceSetup\" as src.setups.source_setup.SourceSetup {\n  antenna : str\n  free_space : bool\n  frequency_mhz : int\n  simulation : str\n  units\n  __init__(config: 'Config', simulation: 'emfdtd.Simulation', frequency_mhz: int, antenna: 'Antenna', verbose_logger: 'Logger', progress_logger: 'Logger', free_space: bool)\n  setup_source_and_sensors(antenna_components: dict)\n}\nclass \"StudyCancelledError\" as src.utils.StudyCancelledError {\n}\nclass \"Worker\" as src.osparc_batch.worker.Worker {\n  client_cfg : NoneType\n  config : NoneType\n  config_path : str\n  download_and_process_results : Callable[..., Any]\n  download_executor : ThreadPoolExecutor\n  downloaded_jobs : set\n  file_retries : dict\n  file_to_job_id : dict\n  finished\n  get_osparc_client_config : Callable[..., Any]\n  get_progress_report : Callable[..., str]\n  input_files : list\n  job_statuses : dict\n  jobs_being_downloaded : set\n  logger : Logger\n  main_process_logic : Callable[..., Any]\n  progress\n  running_jobs : dict\n  status_update_requested\n  stop_requested : bool\n  timer\n  __init__(config_path: str, logger: logging.Logger, get_osparc_client_config_func: Callable[..., Any], download_and_process_results_func: Callable[..., Any], get_progress_report_func: Callable[..., str], main_process_logic_func: Callable[..., Any])\n  _check_jobs_status()\n  _download_job_in_thread(job, solver, file_path: Path)\n  _update_job_status(job_id: str, status: str)\n  cancel_jobs()\n  request_progress_report()\n  run()\n  stop()\n}\nsrc.analysis.far_field_strategy.FarFieldAnalysisStrategy --|&gt; src.analysis.base_strategy.BaseAnalysisStrategy\nsrc.analysis.near_field_strategy.NearFieldAnalysisStrategy --|&gt; src.analysis.base_strategy.BaseAnalysisStrategy\nsrc.analysis.strategies.FarFieldAnalysisStrategy --|&gt; src.analysis.strategies.BaseAnalysisStrategy\nsrc.analysis.strategies.NearFieldAnalysisStrategy --|&gt; src.analysis.strategies.BaseAnalysisStrategy\nsrc.extraction.power_extractor.PowerExtractor --|&gt; src.logging_manager.LoggingMixin\nsrc.extraction.sar_extractor.SarExtractor --|&gt; src.logging_manager.LoggingMixin\nsrc.gui_manager.QueueGUI --|&gt; src.logging_manager.LoggingMixin\nsrc.project_manager.ProjectManager --|&gt; src.logging_manager.LoggingMixin\nsrc.results_extractor.ResultsExtractor --|&gt; src.logging_manager.LoggingMixin\nsrc.setups.base_setup.BaseSetup --|&gt; src.logging_manager.LoggingMixin\nsrc.setups.boundary_setup.BoundarySetup --|&gt; src.setups.base_setup.BaseSetup\nsrc.setups.far_field_setup.FarFieldSetup --|&gt; src.setups.base_setup.BaseSetup\nsrc.setups.gridding_setup.GriddingSetup --|&gt; src.setups.base_setup.BaseSetup\nsrc.setups.material_setup.MaterialSetup --|&gt; src.setups.base_setup.BaseSetup\nsrc.setups.near_field_setup.NearFieldSetup --|&gt; src.setups.base_setup.BaseSetup\nsrc.setups.phantom_setup.PhantomSetup --|&gt; src.setups.base_setup.BaseSetup\nsrc.setups.placement_setup.PlacementSetup --|&gt; src.setups.base_setup.BaseSetup\nsrc.setups.source_setup.SourceSetup --|&gt; src.setups.base_setup.BaseSetup\nsrc.simulation_runner.SimulationRunner --|&gt; src.logging_manager.LoggingMixin\nsrc.studies.base_study.BaseStudy --|&gt; src.logging_manager.LoggingMixin\nsrc.studies.far_field_study.FarFieldStudy --|&gt; src.studies.base_study.BaseStudy\nsrc.studies.near_field_study.NearFieldStudy --|&gt; src.studies.base_study.BaseStudy\nsrc.analysis.plotter.Plotter --* src.analysis.analyzer.Analyzer : plotter\nsrc.config.Config --* src.studies.base_study.BaseStudy : config\nsrc.profiler.Profiler --* src.studies.base_study.BaseStudy : profiler\nsrc.project_manager.ProjectManager --* src.studies.base_study.BaseStudy : project_manager\nsrc.config.Config --o src.osparc_batch.worker.Worker : config\n@enduml\n\n\n\n\n\nPackages Diagram\n\nCould not retrieve image data, got: Forbidden [403]<p></p><pre><code>@startuml packages_GOLIAT\nskinparam linetype ortho\nskinparam ranksep 200\nset namespaceSeparator none\npackage \"src\" as src {\n}\npackage \"src.analysis\" as src.analysis {\n}\npackage \"src.analysis.analyzer\" as src.analysis.analyzer {\n}\npackage \"src.analysis.base_strategy\" as src.analysis.base_strategy {\n}\npackage \"src.analysis.far_field_strategy\" as src.analysis.far_field_strategy {\n}\npackage \"src.analysis.near_field_strategy\" as src.analysis.near_field_strategy {\n}\npackage \"src.analysis.plotter\" as src.analysis.plotter {\n}\npackage \"src.analysis.strategies\" as src.analysis.strategies {\n}\npackage \"src.antenna\" as src.antenna {\n}\npackage \"src.colors\" as src.colors {\n}\npackage \"src.config\" as src.config {\n}\npackage \"src.data_extractor\" as src.data_extractor {\n}\npackage \"src.extraction\" as src.extraction {\n}\npackage \"src.extraction.cleaner\" as src.extraction.cleaner {\n}\npackage \"src.extraction.json_encoder\" as src.extraction.json_encoder {\n}\npackage \"src.extraction.power_extractor\" as src.extraction.power_extractor {\n}\npackage \"src.extraction.reporter\" as src.extraction.reporter {\n}\npackage \"src.extraction.sar_extractor\" as src.extraction.sar_extractor {\n}\npackage \"src.extraction.sensor_extractor\" as src.extraction.sensor_extractor {\n}\npackage \"src.gui_manager\" as src.gui_manager {\n}\npackage \"src.logging_manager\" as src.logging_manager {\n}\npackage \"src.osparc_batch\" as src.osparc_batch {\n}\npackage \"src.osparc_batch.cleanup\" as src.osparc_batch.cleanup {\n}\npackage \"src.osparc_batch.file_finder\" as src.osparc_batch.file_finder {\n}\npackage \"src.osparc_batch.gui\" as src.osparc_batch.gui {\n}\npackage \"src.osparc_batch.logging_utils\" as src.osparc_batch.logging_utils {\n}\npackage \"src.osparc_batch.main_logic\" as src.osparc_batch.main_logic {\n}\npackage \"src.osparc_batch.osparc_client\" as src.osparc_batch.osparc_client {\n}\npackage \"src.osparc_batch.progress\" as src.osparc_batch.progress {\n}\npackage \"src.osparc_batch.runner\" as src.osparc_batch.runner {\n}\npackage \"src.osparc_batch.worker\" as src.osparc_batch.worker {\n}\npackage \"src.profiler\" as src.profiler {\n}\npackage \"src.project_manager\" as src.project_manager {\n}\npackage \"src.results_extractor\" as src.results_extractor {\n}\npackage \"src.setups\" as src.setups {\n}\npackage \"src.setups.base_setup\" as src.setups.base_setup {\n}\npackage \"src.setups.boundary_setup\" as src.setups.boundary_setup {\n}\npackage \"src.setups.far_field_setup\" as src.setups.far_field_setup {\n}\npackage \"src.setups.gridding_setup\" as src.setups.gridding_setup {\n}\npackage \"src.setups.material_setup\" as src.setups.material_setup {\n}\npackage \"src.setups.near_field_setup\" as src.setups.near_field_setup {\n}\npackage \"src.setups.phantom_setup\" as src.setups.phantom_setup {\n}\npackage \"src.setups.placement_setup\" as src.setups.placement_setup {\n}\npackage \"src.setups.source_setup\" as src.setups.source_setup {\n}\npackage \"src.simulation_runner\" as src.simulation_runner {\n}\npackage \"src.studies\" as src.studies {\n}\npackage \"src.studies.base_study\" as src.studies.base_study {\n}\npackage \"src.studies.far_field_study\" as src.studies.far_field_study {\n}\npackage \"src.studies.near_field_study\" as src.studies.near_field_study {\n}\npackage \"src.utils\" as src.utils {\n}\nsrc.analysis.analyzer --&gt; src.analysis.plotter\nsrc.analysis.far_field_strategy --&gt; src.analysis.base_strategy\nsrc.analysis.near_field_strategy --&gt; src.analysis.base_strategy\nsrc.extraction --&gt; src.extraction.cleaner\nsrc.extraction --&gt; src.extraction.power_extractor\nsrc.extraction --&gt; src.extraction.reporter\nsrc.extraction --&gt; src.extraction.sar_extractor\nsrc.extraction --&gt; src.extraction.sensor_extractor\nsrc.gui_manager --&gt; src.logging_manager\nsrc.gui_manager --&gt; src.profiler\nsrc.gui_manager --&gt; src.utils\nsrc.logging_manager --&gt; src.colors\nsrc.osparc_batch.cleanup --&gt; src.osparc_batch.logging_utils\nsrc.osparc_batch.file_finder --&gt; src.osparc_batch.logging_utils\nsrc.osparc_batch.main_logic --&gt; src.osparc_batch.logging_utils\nsrc.osparc_batch.main_logic --&gt; src.osparc_batch.osparc_client\nsrc.osparc_batch.osparc_client --&gt; src.osparc_batch.logging_utils\nsrc.osparc_batch.progress --&gt; src.osparc_batch.logging_utils\nsrc.osparc_batch.runner --&gt; src.config\nsrc.osparc_batch.runner --&gt; src.osparc_batch.cleanup\nsrc.osparc_batch.runner --&gt; src.osparc_batch.file_finder\nsrc.osparc_batch.runner --&gt; src.osparc_batch.gui\nsrc.osparc_batch.runner --&gt; src.osparc_batch.logging_utils\nsrc.osparc_batch.runner --&gt; src.osparc_batch.main_logic\nsrc.osparc_batch.runner --&gt; src.osparc_batch.osparc_client\nsrc.osparc_batch.runner --&gt; src.osparc_batch.progress\nsrc.osparc_batch.runner --&gt; src.osparc_batch.worker\nsrc.osparc_batch.worker --&gt; src.osparc_batch.runner\nsrc.project_manager --&gt; src.logging_manager\nsrc.project_manager --&gt; src.utils\nsrc.results_extractor --&gt; src.extraction.cleaner\nsrc.results_extractor --&gt; src.extraction.json_encoder\nsrc.results_extractor --&gt; src.extraction.power_extractor\nsrc.results_extractor --&gt; src.extraction.reporter\nsrc.results_extractor --&gt; src.extraction.sar_extractor\nsrc.results_extractor --&gt; src.extraction.sensor_extractor\nsrc.results_extractor --&gt; src.logging_manager\nsrc.setups.base_setup --&gt; src.logging_manager\nsrc.setups.boundary_setup --&gt; src.setups.base_setup\nsrc.setups.far_field_setup --&gt; src.setups.base_setup\nsrc.setups.far_field_setup --&gt; src.setups.boundary_setup\nsrc.setups.far_field_setup --&gt; src.setups.gridding_setup\nsrc.setups.far_field_setup --&gt; src.setups.material_setup\nsrc.setups.gridding_setup --&gt; src.setups.base_setup\nsrc.setups.material_setup --&gt; src.setups.base_setup\nsrc.setups.near_field_setup --&gt; src.setups.base_setup\nsrc.setups.near_field_setup --&gt; src.setups.boundary_setup\nsrc.setups.near_field_setup --&gt; src.setups.gridding_setup\nsrc.setups.near_field_setup --&gt; src.setups.material_setup\nsrc.setups.near_field_setup --&gt; src.setups.phantom_setup\nsrc.setups.near_field_setup --&gt; src.setups.placement_setup\nsrc.setups.near_field_setup --&gt; src.setups.source_setup\nsrc.setups.phantom_setup --&gt; src.setups.base_setup\nsrc.setups.placement_setup --&gt; src.setups.base_setup\nsrc.setups.source_setup --&gt; src.setups.base_setup\nsrc.simulation_runner --&gt; src.logging_manager\nsrc.simulation_runner --&gt; src.utils\nsrc.studies.base_study --&gt; src.config\nsrc.studies.base_study --&gt; src.logging_manager\nsrc.studies.base_study --&gt; src.profiler\nsrc.studies.base_study --&gt; src.project_manager\nsrc.studies.base_study --&gt; src.utils\nsrc.studies.far_field_study --&gt; src.studies.base_study\nsrc.studies.near_field_study --&gt; src.studies.base_study\nsrc.analysis.analyzer ..&gt; src.analysis.base_strategy\nsrc.analysis.base_strategy ..&gt; src.analysis.analyzer\nsrc.analysis.base_strategy ..&gt; src.analysis.plotter\nsrc.analysis.far_field_strategy ..&gt; src.analysis.analyzer\nsrc.analysis.far_field_strategy ..&gt; src.analysis.plotter\nsrc.analysis.near_field_strategy ..&gt; src.analysis.analyzer\nsrc.analysis.near_field_strategy ..&gt; src.analysis.plotter\nsrc.antenna ..&gt; src.config\nsrc.osparc_batch.file_finder ..&gt; src.config\nsrc.osparc_batch.main_logic ..&gt; src.osparc_batch.worker\nsrc.osparc_batch.osparc_client ..&gt; src.config\nsrc.project_manager ..&gt; src.config\nsrc.project_manager ..&gt; src.gui_manager\nsrc.results_extractor ..&gt; src.config\nsrc.results_extractor ..&gt; src.gui_manager\nsrc.results_extractor ..&gt; src.studies.base_study\nsrc.setups.far_field_setup ..&gt; src.setups.phantom_setup\nsrc.simulation_runner ..&gt; src.config\nsrc.simulation_runner ..&gt; src.gui_manager\nsrc.simulation_runner ..&gt; src.studies.base_study\nsrc.utils ..&gt; src.studies.base_study\n@enduml\n</code></pre>\n\n\n\n<p>How to view\n- Right click the above image and open in a new tab. Zoom in and pan around.\n- Alternatively, use any PlantUML viewer (e.g., VS Code PlantUML extension, IntelliJ PlantUML plugin, or https://www.plantuml.com/plantuml).</p>"},{"location":"user_guide/","title":"\ud83d\udcd6 User Guide: Understanding GOLIAT Workflows","text":"<p>This guide provides a comprehensive, plain-language explanation of how GOLIAT operates, serving as your essential roadmap for running and analyzing EMF dosimetry simulations. We'll delve into the end-to-end workflows for both near-field (device close to the body, like a mobile phone) and far-field (whole-body exposure, such as environmental plane waves) scenarios.</p> <p>GOLIAT automates the intricate and often tedious aspects of EMF simulations: from downloading necessary models and constructing complex scenes in Sim4Life, to executing calculations and extracting critical metrics like Specific Absorption Rate (SAR).</p>"},{"location":"user_guide/#key-concepts-in-emf-dosimetry","title":"\ud83d\udca1 Key concepts in EMF dosimetry","text":"<p>Before diving into the workflows, let's clarify some fundamental terms:</p> <ul> <li>Phantoms: These are highly detailed digital human models (e.g., \"thelonious\" represents a 6-year-old boy, \"eartha\" an adult female). They serve as realistic 3D representations for safe and accurate simulation of EMF interaction with biological tissues.</li> <li>Near-Field Simulations: Focus on scenarios where an EMF source (e.g., an antenna in a mobile device) is in close proximity to the body. These simulations are crucial for assessing localized absorption, particularly in sensitive areas like the head, eyes, or limbs.</li> <li>Far-Field Simulations: Address scenarios involving plane waves impinging on the entire body from various directions (e.g., front, back, sides). These are typically used for evaluating environmental or broadcast exposure.</li> <li>Specific Absorption Rate (SAR): The primary output metric, representing the rate at which electromagnetic energy is absorbed per unit mass of biological tissue, typically expressed in milliwatts per kilogram (mW/kg) per 1W of input power. GOLIAT provides whole-body average SAR, localized SAR (e.g., head/trunk), and peak spatial-average SAR (psSAR) over 10g tissue cubes in specific organs (e.g., brain, eyes, skin).</li> <li>Configuration Files (Configs): JSON files that serve as the \"recipe\" for your simulations. They define all parameters, including phantom selection, frequencies, antenna properties, and execution controls. GOLIAT uses a hierarchical system where study-specific configs inherit from <code>base_config.json</code>, allowing for easy customization and overrides.</li> </ul>"},{"location":"user_guide/#end-to-end-workflow-from-config-to-analysis","title":"\ud83d\ude80 End-to-end workflow: from config to analysis","text":"<p>GOLIAT's robust and modular design follows a clear, sequential flow: Load Config \u2192 Orchestrate Study \u2192 Setup Scene \u2192 Run Simulation \u2192 Extract Results \u2192 Analyze &amp; Plot.</p>"},{"location":"user_guide/#1-load-configuration","title":"1. Load configuration","text":"<p>Your journey begins by specifying a configuration file. -   Execute your study using the command line:     <pre><code>python run_study.py --config configs/your_study_config.json\n</code></pre> -   GOLIAT intelligently merges your chosen configuration (e.g., <code>near_field_config.json</code>) with the <code>base_config.json</code>, applying overrides for specific parameters like solver settings or gridding refinements. -   A graphical user interface (GUI) will launch. Here, you can your configuration will be loaded and the study will initiate.</p> <p>\ud83d\udca1 Pro Tip: Configuration files are human-readable JSON. We recommend editing them in a code editor like VS Code. Start by copying one of the provided templates (e.g., <code>near_field_config.json</code>) and modify only the parameters relevant to your study, such as phantoms or frequencies. Refer to the Configuration Guide for a detailed breakdown of all parameters.</p>"},{"location":"user_guide/#2-orchestrate-study","title":"2. Orchestrate study","text":"<p>The core logic of your simulation is managed by specialized Study classes (<code>NearFieldStudy</code> or <code>FarFieldStudy</code>).</p> <ul> <li>Near-Field Example: If you're running a near-field study, the <code>NearFieldStudy</code> class will systematically loop through all defined phantoms, frequencies, and antenna placements. For instance, it might process \"thelonious\" phantom at 700 MHz with an antenna placed \"by_cheek\" (e.g., 8mm from the cheek).</li> <li>Far-Field Example: For far-field studies, the <code>FarFieldStudy</code> class iterates through phantoms, frequencies, incident directions (e.g., x_pos, y_neg), and polarizations (e.g., theta, phi).</li> <li>Project Management: For each unique simulation scenario, GOLIAT creates a dedicated Sim4Life project file (<code>.smash</code>) within a structured <code>results/</code> directory. For a near-field study, this would be <code>results/near_field/thelonious/700MHz/by_cheek/</code>. For a far-field study, each simulation gets its own directory, like <code>results/far_field/thelonious/700MHz/environmental_x_pos_theta/</code>.</li> <li>Progress Tracking: The GUI provides real-time progress updates and a guess for the Time Remaining, which becomes more accurate over time as GOLIAT learns from previous runs (these are stored in <code>configs/profiling_config.json</code>).</li> </ul>"},{"location":"user_guide/#3-setup-scene-in-sim4life","title":"3. Setup scene in Sim4Life","text":"<p>This phase involves GOLIAT automatically constructing the 3D simulation environment within Sim4Life.</p> <ul> <li>Phantom Loading: The specified digital phantom model is downloaded (if not already present) and imported into the scene, complete with its detailed tissue segmentation (e.g., skin, brain, muscle).</li> <li>Antenna/Source Placement:<ul> <li>Near-Field: The CAD model of the antenna (e.g., PIFA or IFA type) is imported and precisely positioned relative to the phantom, according to the defined placement scenario (e.g., 8mm gap from the cheek, with a specific tilt).</li> <li>Far-Field: Instead of an antenna, a plane wave source is configured, specifying its electric field strength (e.g., 1 V/m), incident direction, and polarization.</li> </ul> </li> <li>Material Assignment: Appropriate electromagnetic properties (e.g., conductivity, permittivity) are assigned to all entities in the scene (tissues, antenna components) based on the specified frequency.</li> <li>Gridding: The simulation domain is discretized into a computational grid. GOLIAT intelligently applies gridding rules, using finer cells around critical areas like the antenna or phantom surface, and coarser cells elsewhere. This can be automatic or manually controlled via millimeter steps.</li> <li>Scene Optimization: For certain placements like <code>by_cheek</code>, GOLIAT automatically rotates the entire simulation scene to align the phone with the grid, which can significantly speed up simulation time.</li> <li>Boundaries and Sensors: Perfectly Matched Layer (PML) boundaries are configured to absorb outgoing electromagnetic waves, preventing reflections. Point sensors are strategically placed at the corners of the simulation bounding box to monitor field values for convergence.</li> <li>Solver Configuration: The Finite-Difference Time-Domain (FDTD) solver from <code>iSolve.exe</code> is set up, typically leveraging GPU acceleration (e.g., Acceleware or CUDA kernel) for faster computation.</li> </ul>"},{"location":"user_guide/#4-run-simulation","title":"4. Run simulation","text":"<p>With the scene meticulously set up, GOLIAT proceeds to execute the electromagnetic simulation.</p> <ul> <li>Local Execution: For local runs, GOLIAT directly invokes the Sim4Life <code>iSolve.exe</code> solver. The GUI remains responsive, displaying logs and progress updates as the solver runs.</li> <li>Cloud Execution (oSPARC): For large-scale or parallel studies, GOLIAT can generate the necessary input files (<code>.h5</code>) and submit them as jobs to the oSPARC cloud platform. It then monitors the status of these jobs (e.g., PENDING \u2192 RUNNING \u2192 SUCCESS).</li> <li>Duration: A single simulation can take anywhere from 5 to 5 hours, depending on factors like grid resolution, frequency, and computational resources. All results are normalized to a 1W input power for consistency.</li> </ul> <p>Batch Mode: By setting <code>\"batch_run\": true</code> in your configuration, GOLIAT can manage multiple simulations concurrently, either locally (using <code>run_parallel_studies.py</code>) or on oSPARC. The GUI tracks the status of all jobs and automatically downloads results upon completion.</p>"},{"location":"user_guide/#5-extract-analyze-results","title":"5. Extract &amp; analyze results","text":"<p>After the simulation, GOLIAT's <code>ResultsExtractor</code> and <code>Analyzer</code> components take over to process and interpret the vast amount of raw data.</p> <ul> <li>SAR Extraction: The extractor pulls various SAR metrics from the simulation output:<ul> <li>Whole-Body SAR: The average SAR over the entire phantom.</li> <li>Localized SAR: Average SAR in specific regions, such as the head or trunk, relevant for localized exposures.</li> <li>psSAR10g: Peak spatial-average SAR over a 10-gram tissue cube, typically reported for sensitive organs like the eyes, brain, and skin.</li> <li>Power Balance: A crucial check to ensure energy conservation within the simulation, ideally close to 100%.</li> </ul> </li> <li>Normalization: All extracted SAR values are normalized to a 1W input power, providing a standardized basis for comparison.</li> <li>Output Files (located in the <code>results/</code> folder):<ul> <li><code>sar_results.json</code>: A JSON file containing the primary normalized SAR values.</li> <li><code>sar_stats_all_tissues.pkl</code>: A Python pickle file with detailed, tissue-specific SAR data.</li> <li>Plots: GOLIAT automatically generates a suite of visualizations, including SAR heatmaps (showing SAR distribution by tissue and frequency), bar charts (comparing SAR in different regions), and boxplots (illustrating SAR distributions).</li> </ul> </li> <li>Aggregated Analysis: You can run the dedicated analysis script (<code>python run_analysis.py --config your_config.json</code>) to aggregate results across multiple simulations and generate comprehensive CSV reports and additional plots.</li> <li>Log Files: For debugging and detailed tracking, GOLIAT generates two types of log files in the <code>logs/</code> directory for each run: a <code>.progress.log</code> for high-level updates and a <code>.log</code> for verbose, detailed information. The system automatically manages these files, keeping a maximum of 15 pairs to prevent excessive disk usage.</li> </ul> <p>Example Output Interpretation: For a near-field 700MHz simulation with an antenna by the cheek, you might observe: -   Head SAR: 0.5 mW/kg (per 1W input). -   Brain psSAR10g: 2.1 mW/kg peak. For far-field studies, the analysis often involves averaging results over different incident directions to determine typical exposure scenarios.</p> <p>\ud83d\udca1 If you simulate the whole-body, you get an overview of all the SAR values in each tissue (as defined by Sim4Life), their psSAR10g values and more! This is also displayed in HTML files. Moreover, we define a number of tissue groups of interest, including the eyes, head, skin and genitals which aggregate the above results for groups of tissues (as defined in <code>data/material_name_mapping.json</code>).</p>"},{"location":"user_guide/#near-field-vs-far-field-workflows-a-comparison","title":"\ud83d\udd04 Near-field vs. far-field workflows: a comparison","text":"<p>While the core GOLIAT workflow remains consistent, the specifics of scene setup and analysis differ between near-field and far-field studies.</p>"},{"location":"user_guide/#near-field-workflow-device-exposure","title":"Near-field workflow (device exposure)","text":"<ul> <li>Primary Use Case: Assessing localized EMF exposure from devices held close to the body, such as mobile phones, wearables, or other devices. The focus is on SAR in specific tissues and organs.</li> <li>Key Steps:<ol> <li>Configuration: Set <code>\"study_type\": \"near_field\"</code> and define specific <code>placement_scenarios</code> (e.g., \"by_cheek\", \"on_wrist\").</li> <li>Scene Setup: Involves importing a detailed CAD model of the device antenna and precisely positioning it relative to the phantom, often with a small air gap (e.g., 8mm).</li> <li>Simulation Run: Typically uses a harmonic excitation (single frequency) to simulate continuous wave exposure.</li> <li>Results Analysis: Concentrates on localized SAR values (e.g., head SAR, trunk SAR) and peak spatial-average SAR (psSAR10g) in sensitive tissues like the eyes, brain, and skin.</li> </ol> </li> <li>Free-Space Mode: GOLIAT supports a \"freespace\" phantom option, allowing you to run simulations of the antenna in isolation (without a body). This is useful for antenna characterization and validation.</li> </ul>"},{"location":"user_guide/#far-field-workflow-environmental-exposure","title":"Far-field workflow (environmental exposure)","text":"<ul> <li>Primary Use Case: Evaluating whole-body EMF exposure from distant sources, such as broadcast antennas, cellular base stations, or industrial equipment. The focus is on whole-body average SAR and overall field distribution. We reduce the complexity of impinging fields to all orthogonal directions and two polarizations, and assume that by normalizing this to 1 W, we can construct a transfer functions between measured E-field values and absorption values, especially for channel scenarios where the user is not down- or uploading anything.</li> <li>Key Steps:<ol> <li>Configuration: Set <code>\"study_type\": \"far_field\"</code> and define <code>incident_directions</code> (e.g., <code>[\"x_pos\", \"y_neg\"]</code>) and <code>polarizations</code> (e.g., <code>[\"theta\", \"phi\"]</code>).</li> <li>Scene Setup: Instead of a device, plane wave sources are configured to illuminate the phantom from multiple directions, covering a full range of exposure angles.</li> <li>Simulation Run: Multiple simulations are typically run for each frequency, covering all specified directions and polarizations (e.g., 12 simulations per frequency: 6 directions \u00d7 2 polarizations).</li> <li>Results Analysis: Focuses on whole-body average SAR and how SAR is distributed across the entire phantom, often aggregated over various exposure scenarios.</li> </ol> </li> <li>Auto-Induced Mode: While currently a placeholder, this mode is envisioned for future implementations to simulate EMF exposure induced by body motion or other dynamic scenarios.</li> </ul>"},{"location":"user_guide/#tips-for-success","title":"\u2705 Tips for success","text":"<ul> <li>Scale Up Your Studies: For multi-core local execution, leverage <code>run_parallel_studies.py --num-splits 4</code> to distribute simulations across multiple CPU cores.</li> <li>Cloud Computing with oSPARC: For hundreds or thousands of simulations, oSPARC offers a cost-effective and fast cloud solution. Remember to set up your API keys in a <code>.env</code> file.</li> <li>Manage Disk Space: For serial workflows on machines with limited storage, use <code>\"auto_cleanup_previous_results\": [\"output\"]</code> to automatically delete previous simulation files. See Configuration Guide for details.</li> <li>Customize with Confidence: Feel free to modify frequencies and placements in your configuration files. However, for consistency with GOLIAT's protocols, it's generally recommended to keep the core antenna models fixed.</li> <li>Effective Debugging: Always consult the <code>logs/</code> directory for detailed error messages. You can also rerun specific phases of a study (e.g., <code>\"do_setup\": false, \"do_run\": false, \"do_extract\": true</code>) to isolate and debug issues more efficiently.</li> </ul> <p>You are now equipped to navigate GOLIAT and perform sophisticated EMF dosimetry simulations! For hands-on examples, proceed to the Tutorials. If you have any further questions or encounter issues, please open a GitHub Issue.</p> <p>Last updated: {date}</p>"},{"location":"tutorials/advanced/","title":"Advanced Tutorial: oSPARC Batching and Parallel Execution","text":"<p>This tutorial covers scaling simulations with oSPARC cloud batching and local parallel execution. oSPARC is useful for large studies (hundreds of simulations), while parallel uses multiple CPU cores locally.</p>"},{"location":"tutorials/advanced/#prerequisites","title":"Prerequisites","text":"<p>Complete Basic Tutorial. For oSPARC, add API keys to <code>.env</code> (see User Guide).</p>"},{"location":"tutorials/advanced/#osparc-batching","title":"oSPARC batching","text":"<p>oSPARC allows parallel cloud runs. Workflow: Generate inputs locally \u2192 Submit batch \u2192 Download results \u2192 Extract.</p>"},{"location":"tutorials/advanced/#step-1-generate-input-files","title":"Step 1: Generate input files","text":"<p>Edit your config (e.g., <code>configs/my_advanced.json</code>):</p> <pre><code>{\n  \"extends\": \"base_config.json\",\n  \"study_type\": \"far_field\",\n  \"phantoms\": [\"thelonious\", \"eartha\"],\n  \"frequencies_mhz\": [700, 900],\n  \"execution_control\": {\n    \"do_setup\": true,\n    \"only_write_input_file\": true,  // Generate .h5 files only\n    \"do_run\": false,\n    \"do_extract\": false,\n    \"batch_run\": false\n  }\n}\n</code></pre> <p>Run:</p> <pre><code>python run_study.py --config configs/my_advanced.json\n</code></pre> <ul> <li>Outputs .h5 input files in <code>results/far_field/{phantom}/{freq}MHz/{project}.smash_Results/</code>.</li> </ul>"},{"location":"tutorials/advanced/#step-2-submit-batch-to-osparc","title":"Step 2: Submit batch to oSPARC","text":"<p>Update config for submission:</p> <pre><code>{\n  \"execution_control\": {\n    \"batch_run\": true  // Enable batch submission\n  }\n}\n</code></pre> <p>Run:</p> <pre><code>python run_study.py --config configs/my_advanced.json\n</code></pre> <ul> <li>GUI monitors jobs (PENDING \u2192 SUCCESS).</li> <li>Handles submission, polling, downloads automatically.</li> <li>Logs in <code>logs/osparc_submission_logs/</code>.</li> </ul> <p>Notes: - Max ~61 parallel jobs (oSPARC limit). - Costs: Based on compute time; monitor in oSPARC dashboard. - Pitfalls: Ensure .env keys valid; check quotas. If job fails, retry with <code>\"do_run\": false, \"do_extract\": true</code>.</p>"},{"location":"tutorials/advanced/#step-3-extract-results","title":"Step 3: Extract results","text":"<p>After jobs complete (GUI shows COMPLETED), update config:</p> <pre><code>{\n  \"execution_control\": {\n    \"do_setup\": false,\n    \"do_run\": false,\n    \"do_extract\": true,\n    \"batch_run\": false\n  }\n}\n</code></pre> <p>Run:</p> <pre><code>python run_study.py --config configs/my_advanced.json\n</code></pre> <ul> <li>Processes downloaded results into JSON/CSV/plots.</li> </ul> <p>Expected: Aggregated SAR over phantoms/freqs, plots in <code>results/far_field/plots/</code>.</p>"},{"location":"tutorials/advanced/#local-parallel-execution","title":"Local parallel execution","text":"<p>For multi-core local runs, use <code>run_parallel_studies.py</code>. Splits config into subsets (e.g., phantoms or frequencies).</p>"},{"location":"tutorials/advanced/#step-1-prepare-config","title":"Step 1: Prepare config","text":"<p>Use a large config (e.g., full near-field with multiple freqs/phantoms).</p>"},{"location":"tutorials/advanced/#step-2-split-and-run","title":"Step 2: Split and run","text":"<p>Run:</p> <pre><code>python run_parallel_studies.py --config configs/near_field_config.json --num-splits 4\n</code></pre> <ul> <li>Splits: 4 configs in <code>configs/near_field_config_parallel/</code> (e.g., by phantoms).</li> <li>Launches 4 <code>run_study.py</code> processes (one GUI per process).</li> <li>Each handles subset; results merge in <code>results/</code>.</li> </ul> <p>Splitting Logic (from code): - 2 splits: Halve phantoms. - 4 splits: One per first 4 phantoms. - 8 splits: Split phantoms, then halve frequencies.</p> <p>Use <code>--skip-split</code> for existing split dir.</p> <p>Notes: Local parallel uses CPU cores; no cloud needed. For large studies, combine with batch for hybrid.</p>"},{"location":"tutorials/advanced/#comparing-results","title":"Comparing results","text":"<p>After batch/parallel run, run analysis:</p> <pre><code>python run_analysis.py --config configs/my_advanced.json\n</code></pre> <ul> <li>Aggregates all results.</li> <li>Plots: SAR distributions across scenarios.</li> </ul>"},{"location":"tutorials/advanced/#troubleshooting","title":"Troubleshooting","text":"<ul> <li>oSPARC: \"Invalid API key\" \u2013 Check .env; regenerate keys.</li> <li>Parallel: \"Lock file\" \u2013 Delete stale <code>.lock</code> files in root.</li> <li>Memory: Reduce splits if RAM low.</li> </ul> <p>For more config details, see Configuration Guide.</p>"},{"location":"tutorials/basic/","title":"Basic Tutorial: Running a Default Study","text":"<p>This tutorial shows how to run a default near-field study using the provided configuration. It uses the \"thelonious\" phantom at 700 MHz with a cheek placement. The process includes loading the config, executing the simulation, and reviewing the results.</p>"},{"location":"tutorials/basic/#prerequisites","title":"Prerequisites","text":"<p>Follow the Quick Start to install dependencies and set up Sim4Life.</p>"},{"location":"tutorials/basic/#step-1-use-the-default-config","title":"Step 1: Use the default config","text":"<p>The default near-field configuration is <code>configs/near_field_config.json</code>. For this tutorial, we limit to one phantom and frequency for simplicity.</p> <p>Key settings in <code>near_field_config.json</code>: - <code>study_type</code>: \"near_field\" - <code>phantoms</code>: [\"thelonious\"] (6-year-old male phantom) - <code>frequencies_mhz</code>: [700] (single frequency; full config has more) - Placement: \"by_cheek\" (antenna 8 mm from cheek, default for this scenario)</p> <p>The config inherits from <code>base_config.json</code> for common settings like solver and gridding.</p>"},{"location":"tutorials/basic/#step-2-execute-the-study","title":"Step 2: Execute the study","text":"<p>Run the study from the terminal:</p> <pre><code>python run_study.py --config configs/near_field_config.json\n</code></pre> <ul> <li>The GUI opens.</li> <li>The process:</li> <li>Downloads the phantom and antenna model if not present.</li> <li>Builds the simulation scene: Loads the phantom, positions the antenna.</li> <li>Configures materials and grid.</li> <li>Runs the simulation using the iSolve solver.</li> <li>Extracts results: SAR values and statistics.</li> </ul> <p>The GUI displays progress, estimated time, and logs. Check the console or <code>logs/</code> for detailed output.</p>"},{"location":"tutorials/basic/#step-3-examine-the-results","title":"Step 3: Examine the results","text":"<p>Results are saved in <code>results/near_field/thelonious/700MHz/by_cheek/</code>:</p> <ul> <li><code>sar_results.json</code>: Summary metrics (e.g., \"head_SAR\": 0.45 mW/kg per 1W input).</li> <li><code>sar_stats_all_tissues.pkl</code>: Detailed SAR for all tissues (use pandas to load).</li> <li><code>sar_stats_all_tissues.html</code>: HTML table of tissue SAR values.</li> <li><code>point_sensor_data.png</code>: E-field magnitude plot at monitoring points (if enabled).</li> </ul> <p>Example from <code>sar_results.json</code>:</p> <pre><code>{\n  \"head_SAR\": 0.45,\n  \"peak_sar_10g_W_kg\": 2.1,\n  \"power_balance\": {\"Balance\": 99.87}\n}\n</code></pre> <p>SAR values are normalized to 1W input power.</p>"},{"location":"tutorials/basic/#step-4-run-the-analysis-script","title":"Step 4: Run the analysis script","text":"<p>To aggregate and visualize results:</p> <pre><code>python run_analysis.py --config configs/near_field_config.json\n</code></pre> <p>This generates: - <code>normalized_results_detailed.csv</code>: Per-simulation data. - <code>normalized_results_summary.csv</code>: Averages by frequency/scenario. - Plots in <code>results/near_field/plots/</code> (e.g., SAR by tissue).</p> <p>Load in Python for further analysis:</p> <pre><code>import pandas as pd\ndf = pd.read_csv(\"results/near_field/normalized_results_detailed.csv\")\nprint(df.describe())\n</code></pre>"},{"location":"tutorials/basic/#troubleshooting","title":"Troubleshooting","text":"<ul> <li>\"Phantom download failed\": Ensure internet and email in <code>base_config.json</code>. Rerun to retry.</li> <li>Simulation slow: Reduce frequencies or use coarser grid in config.</li> <li>No output: Check <code>do_extract: true</code> in config; review logs for errors.</li> </ul>"},{"location":"tutorials/basic/#next-steps","title":"Next steps","text":"<ul> <li>Customize placements/frequencies: Intermediate Tutorial.</li> <li>Run far-field: Change config to <code>far_field_config.json</code>.</li> <li>Batch processing: Advanced Tutorial.</li> </ul> <p>This tutorial verifies the basic workflow. For more, see User Guide.</p> <p>Last updated: {date}</p>"},{"location":"tutorials/intermediate/","title":"\ud83e\uddd1\u200d\ud83d\udcbb Intermediate Tutorial: Customizing Placements and Frequencies","text":"<p>This tutorial builds upon the Basic Tutorial by demonstrating how to customize antenna placements and simulation frequencies in GOLIAT. You'll learn to modify configuration files to explore different exposure scenarios.</p>"},{"location":"tutorials/intermediate/#what-youll-achieve","title":"\ud83c\udfaf What you'll achieve","text":"<p>By the end of this tutorial, you will be able to: -   Create a custom configuration file for intermediate studies. -   Define multiple frequencies for a single study. -   Specify custom antenna placements relative to the phantom. -   Run a study with your customized settings.</p>"},{"location":"tutorials/intermediate/#prerequisites","title":"\ud83d\udccb Prerequisites","text":"<p>Ensure you have completed the Basic Tutorial and have a working GOLIAT environment.</p>"},{"location":"tutorials/intermediate/#step-1-create-a-custom-configuration-file","title":"Step 1: Create a custom configuration file","text":"<p>Instead of modifying the default <code>near_field_config.json</code>, we'll create a new configuration file to keep your changes organized.</p> <ol> <li> <p>Copy <code>configs/near_field_config.json</code> to <code>configs/my_intermediate_study.json</code>.     <pre><code>cp configs/near_field_config.json configs/my_intermediate_study.json\n</code></pre></p> </li> <li> <p>Open <code>configs/my_intermediate_study.json</code> in your code editor.</p> </li> </ol>"},{"location":"tutorials/intermediate/#step-2-define-multiple-frequencies","title":"Step 2: Define multiple frequencies","text":"<p>Let's add another frequency to our study. We'll simulate at both 700 MHz and 900 MHz.</p> <p>Locate the <code>\"frequencies_mhz\"</code> array and modify it:</p> <pre><code>{\n  \"extends\": \"base_config.json\",\n  \"study_type\": \"near_field\",\n  \"phantoms\": [\"thelonious\"],\n  \"frequencies_mhz\": [700, 900], // Added 900 MHz\n  \"execution_control\": {\n    \"do_setup\": true,\n    \"do_run\": true,\n    \"do_extract\": true\n  },\n  // ... rest of the config\n}\n</code></pre>"},{"location":"tutorials/intermediate/#step-3-specify-custom-antenna-placements","title":"Step 3: Specify custom antenna placements","text":"<p>GOLIAT allows you to define various antenna placement scenarios. We'll add a new placement called \"by_ear\" and enable it for the \"thelonious\" phantom.</p> <ol> <li> <p>Add a <code>\"placement_scenarios\"</code> block to your <code>my_intermediate_study.json</code> (if it doesn't exist, or modify if it does). This block defines the base positions and orientations.</p> <p><pre><code>{\n  \"extends\": \"base_config.json\",\n  \"study_type\": \"near_field\",\n  \"phantoms\": [\"thelonious\"],\n  \"frequencies_mhz\": [700, 900],\n  \"execution_control\": {\n    \"do_setup\": true,\n    \"do_run\": true,\n    \"do_extract\": true\n  },\n  \"placement_scenarios\": {\n    \"by_cheek\": {\n      \"positions\": {\"base\": [0, 0, 0]},\n      \"orientations\": {\"base\": [], \"up\": [{\"axis\": \"X\", \"angle_deg\": 10}]}\n    },\n    \"by_ear\": { // New placement scenario\n      \"positions\": {\"base\": [0, 50, 0]}, // Example: 50mm along Y-axis from origin\n      \"orientations\": {\"base\": [], \"rotate_z\": [{\"angle_deg\": 90}]} // Example: Rotate 90 deg around Z\n    }\n  },\n  // ... rest of the config\n}\n</code></pre> Note: The exact coordinates and rotations will depend on your antenna model and desired position. These are illustrative examples.</p> </li> <li> <p>Enable the new placement for the \"thelonious\" phantom in the <code>\"phantom_definitions\"</code> section:</p> <pre><code>{\n  // ...\n  \"phantom_definitions\": {\n    \"thelonious\": {\n      \"placements\": {\n        \"do_by_cheek\": true,\n        \"do_by_ear\": true // Enable the new placement\n      },\n      \"distance_from_cheek\": 8,\n      \"distance_from_ear\": 5 // Example: 5mm distance for \"by_ear\"\n    }\n  }\n}\n</code></pre> </li> </ol>"},{"location":"tutorials/intermediate/#step-4-run-the-customized-study","title":"Step 4: Run the customized study","text":"<p>Save your <code>configs/my_intermediate_study.json</code> file. Now, execute the study using your new configuration:</p> <pre><code>python run_study.py --config configs/my_intermediate_study.json\n</code></pre> <p>GOLIAT will now run simulations for: -   \"thelonious\" phantom at 700 MHz with \"by_cheek\" placement. -   \"thelonious\" phantom at 700 MHz with \"by_ear\" placement. -   \"thelonious\" phantom at 900 MHz with \"by_cheek\" placement. -   \"thelonious\" phantom at 900 MHz with \"by_ear\" placement.</p> <p>You will see the GUI update as each simulation scenario is processed.</p>"},{"location":"tutorials/intermediate/#step-5-examine-the-results","title":"Step 5: Examine the results","text":"<p>After the study completes, navigate to your <code>results/</code> directory. You will find new subdirectories corresponding to the additional frequency and placement:</p> <ul> <li><code>results/near_field/thelonious/700MHz/by_ear/</code></li> <li><code>results/near_field/thelonious/900MHz/by_cheek/</code></li> <li><code>results/near_field/thelonious/900MHz/by_ear/</code></li> </ul> <p>Each directory will contain its own <code>sar_results.json</code>, <code>sar_stats_all_tissues.pkl</code>, and plots.</p> <p>Run the analysis script to aggregate all results from this multi-scenario study:</p> <pre><code>python run_analysis.py --config configs/my_intermediate_study.json\n</code></pre> <p>This will generate aggregated CSVs and plots that include data from all frequencies and placements you defined.</p>"},{"location":"tutorials/intermediate/#troubleshooting","title":"\u26a0\ufe0f Troubleshooting","text":"<ul> <li>\"Placement not found\": Double-check that the placement name in <code>\"phantom_definitions\"</code> (e.g., <code>\"do_by_ear\": true</code>) exactly matches a key in your <code>\"placement_scenarios\"</code> block (e.g., <code>\"by_ear\"</code>).</li> <li>JSON Syntax Errors: Ensure your JSON file is correctly formatted. Use a JSON validator if you encounter issues.</li> <li>Simulation Time: Running multiple frequencies and placements will increase the total simulation time. Consider using fewer scenarios for quick tests.</li> </ul>"},{"location":"tutorials/intermediate/#next-steps","title":"\u27a1\ufe0f Next steps","text":"<ul> <li>Advanced Batching: Learn how to run many simulations in parallel using oSPARC cloud batching in the Advanced Tutorial.</li> <li>Far-Field Studies: Explore environmental exposure scenarios by configuring a far-field study.</li> <li>Developer Guide: If you're interested in extending GOLIAT, refer to the Developer Guide.</li> </ul> <p>Last updated: {date}</p>"}]}